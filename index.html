<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://www.struggle3g.com">
  <title>Struggle3g‘s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Coding yourself">
<meta name="keywords" content="iOS,客户端,流媒体,iot,程序猿,程序员,程序猿,devepoer,开源,代码,code,黑客,破解,砸壳,html,用户体验">
<meta property="og:type" content="website">
<meta property="og:title" content="Struggle3g‘s Blog">
<meta property="og:url" content="https://www.struggle3g.com/index.html">
<meta property="og:site_name" content="Struggle3g‘s Blog">
<meta property="og:description" content="Coding yourself">
<meta property="og:locale" content="ch">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Struggle3g‘s Blog">
<meta name="twitter:description" content="Coding yourself">
  
    <link rel="alternative" href="/atom.xml" title="Struggle3g‘s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="https://avatars2.githubusercontent.com/u/11781503?s=400&amp;u=107e857699615c1b9c8114a30a3c7df6fd089175&amp;v=4" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">Struggle3g</a></h1>
		</hgroup>
		
		<p class="header-subtitle">脚踏实地，一步一个脚印！</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/essay/">记录</a></li>
	        
				<li><a href="/Photo/">相册</a></li>
	        
				<li><a href="/Video/">精彩</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/GanggangGao" title="github"><i class="icon-github"></i></a>
		        
					<a class="jianshu" target="_blank" href="https://www.jianshu.com/u/85e7cb4c5145" title="jianshu"><i class="icon-jianshu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://avatars2.githubusercontent.com/u/11781503?s=400&amp;u=107e857699615c1b9c8114a30a3c7df6fd089175&amp;v=4" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">Struggle3g</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>脚踏实地，一步一个脚印！<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/GanggangGao" title="github"><i class="icon-github"></i></a>
			        
						<a class="jianshu" target="_blank" href="https://www.jianshu.com/u/85e7cb4c5145" title="jianshu"><i class="icon-jianshu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 25%"><a href="/">主页</a></li>
		        
					<li style="width: 25%"><a href="/essay/">记录</a></li>
		        
					<li style="width: 25%"><a href="/Photo/">相册</a></li>
		        
					<li style="width: 25%"><a href="/Video/">精彩</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    
<article id="post-iOS晋级知识汇总(一)" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/09/iOS晋级知识汇总(一)/">iOS晋级知识汇总(一)</a>
    </h1>
  

        
        <a href="/2019/07/09/iOS晋级知识汇总(一)/" class="archive-article-date">
  	<time datetime="2019-07-09T13:37:36.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-07-09</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="UItableview相关"><a href="#UItableview相关" class="headerlink" title="UItableview相关"></a>UItableview相关</h1><h2 id="重用机制"><a href="#重用机制" class="headerlink" title="重用机制"></a>重用机制</h2><p>通过下面方法得到cell：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell =  [self.TableView dequeueReusableCellWithIdentifier:identifer];</span><br></pre></td></tr></table></figure>
<p>一般在iOS中，tableview的重用机制，我们在<code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</code>方法中，首先通过<code>dequeueReusableCellWithIdentifier</code>获取重用池中的cell，如果获取的cell是nil那么就重新创建一个新的cell，那么重用机制的原理是什么呢？</p>
<ul>
<li>首先我们刷新数据源的时候，整个重用池里面的cell跟屏幕的高度以及cell的个数有关，屏幕总共能够放下多少个cell那么重用池中就会创建多少个cell比如说：<ul>
<li>当前屏幕中共放下了6个cell，当向上滑动的时候，cell1被隐藏了，相对的cell7从最下面露了出来，这时候就用到了重用机制，Cell1被隐藏时，Cell1的真的对象，就会放入到重用池当中，并且是待重用的状态，而cell7出来以后需要一个新的对象，重用池中有一个待使用的对象，正好被cell7使用，一次类推，随着界面滑动，cell的重用都是按照这个过程来进行的。</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-b35c9f55da6eb647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt=""></p>
<h2 id="数据源同步"><a href="#数据源同步" class="headerlink" title="数据源同步"></a>数据源同步</h2><p>新闻、咨询类的App当中，数据源往往有一个删除操作、还同时需要LoadMore </p>
<ul>
<li>删除操作主线程、LoadMore在子线程</li>
<li>这就需要考虑数据源的同步问题。</li>
</ul>
<p>解决方案一般有2种：</p>
<ul>
<li>并发访问 数据拷贝<ul>
<li>需要记录操作，在子线程返回的数据源在同步记录</li>
<li>在并发任务中没有用户操作延迟问题，对内存会增加</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-b0fa7944d0381bb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="并发方式数据同步.png"></p>
<ul>
<li>串行任务<ul>
<li>子线程和主线程任务同步</li>
<li>要求如果在子线程处理任务比较繁重的时候，删除操作就会出现延迟</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-9142bf20a9125266.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="串行队列数据源同步.png"></p>
<h1 id="事件传递和视图响应"><a href="#事件传递和视图响应" class="headerlink" title="事件传递和视图响应"></a>事件传递和视图响应</h1><p>UIView和CALayer的关系和区别：</p>
<p>UIView中的一个属性layer是CALayer类型变量，UIView中的属性backgroundColor实际上是layer中同名属性的一个包装，UIView的现实部分是由CALayer的contents来决定，contents所对应的是backking store，实际上是bitmap类型的一个位图。</p>
<ul>
<li>UIView为其提供内容，以及负责处理触摸等事件，参与响应链</li>
<li>CALayer负责显示内容contents</li>
</ul>
<p>为什么UIView为其提供内容，以及负责处理触摸等事件，参与响应链，CALayer负责显示内容contents？</p>
<p>设计原则，符合单一原则 ，职责分工。</p>
<h2 id="事件传递机制"><a href="#事件传递机制" class="headerlink" title="事件传递机制"></a>事件传递机制</h2><p>事件传递最主要的两个API： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hitTest</code>最终是哪个视图响应这个事件就返回这个UIView</li>
<li><code>pointInside</code>判断某一个点击的位置是否在当前视图范围内，如果在就返回YES，不在返回NO</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-f8f748b4c5f8fd54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt=""></p>
<p>事件传递的流程:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-52e819d72e569391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件传递过程.png"></p>
<h3 id="hitTest系统内部的调用过程"><a href="#hitTest系统内部的调用过程" class="headerlink" title="hitTest系统内部的调用过程"></a>hitTest系统内部的调用过程</h3><ul>
<li>1、 首先判断view的hidden(是否隐藏)、userinteractionEnabled(是否可以交互)和Alpha(透明度)<ul>
<li>如果不可以直接返回nil</li>
<li>如果可以交互那么就调用走2、</li>
</ul>
</li>
<li>2、 调用<code>pointInside</code>来判断这个点是否在当前视图范围内<ul>
<li>如果不在当前视图，也会返回nil</li>
<li>如果在当前视图，就走3、</li>
</ul>
</li>
<li><p>3、 倒序的形式便利当前view的子视图，便利过程中会调用所有子视图的<code>hitTest</code>的方法。</p>
<ul>
<li>如果便利结束都没有找到对应的子视图去响应这个事件，如果当前位置在当前的视图范围内，就会把当前视图做为最终事件响应视图返回给调用方</li>
<li>假如子视图中的某个<code>hitTest</code>返回了最终的UIView，那么这个视图就做为最终事件响应视图，返回给调用方</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-eb9d5736afffb64f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt=""></p>
</li>
</ul>
<p>例子：</p>
<p>方形的but，我们只需要在圆形范围响应事件：</p>
<p>步骤：</p>
<ul>
<li>首先重写<code>hittest</code>和<code>pointInside</code>方法<ul>
<li><code>hittest</code>方法实现：<ul>
<li>1、判断userInteractionEnabled、isHidden、alpha是否允许，如果不允许直接返回nil</li>
<li>2、调用<code>pointInside</code>方法判断点击事件是否在当前视图，如果不在返回nil</li>
<li>3、如果在当前视图，倒序便利子视图并调用<code>hittest</code>方法，一直便利到最终视图，返回调用者</li>
</ul>
</li>
<li><code>pointInside</code>方法中，根据这个<code>point</code>来判断是否在圆形空间内，如果在返回YES，如果不在返回NO</li>
</ul>
</li>
</ul>
<h2 id="视图响应流程"><a href="#视图响应流程" class="headerlink" title="视图响应流程"></a>视图响应流程</h2><p> uibutton-&gt;UIView-&gt;可能还存在view-&gt;uiwindow-&gt;UIApplication-&gt;UIApplicationDelegate<br>  uibutton-&gt;UIView-&gt;可能还存在view-&gt;UIViewcontroller-&gt;uiwindow-&gt;UIApplication-&gt;UIApplicationDelegate</p>
<p>视图响应的API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br></pre></td></tr></table></figure>
<p>上述方法都是<code>UIResponder</code>的方法，UIView和UIViewController是继承于<code>UIResponder</code>，所以都有这些方法。</p>
<p><strong>事件传递让我们能够找到最终的视图，而最终这个事件是否由你找到的视图来处理的话呢？那就涉及到视图响应链的一个流程机制。</strong></p>
<p>流程：</p>
<ul>
<li>如果说最终视图无法响应</li>
<li>会传递给父视图进行响应，下一个响应者</li>
<li>如果父视图不响应那么继续传给父视图的父视图。</li>
<li>按照上述流程一直向上传递，直到传递给UIApplicationDelegate</li>
<li>假如一直到UIApplicationDelegate还没有找到？<ul>
<li>忽略这个响应</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-d76d83554c38d4e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="响应链.png"></p>
<h1 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h1><p>CPU和GPU两个硬件都是通过总线连接起来的。CPU输出的结果一般都是位图，在经过总线在合适的时机上传给GPU， GPU拿到位图以后，会做图层的一些渲染，包括纹理的合成之后会把结果放到Frame Buffer(缓冲区)由视频控制器根据信号在指定时间之前，去提取在帧缓冲区中的屏幕显示内容然后最终显示到手机屏幕上。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-69945f8e6fb7c191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图像显示原理.png"></p>
<p>UIView显示部分是由CALayer来负责的，而CALayer中有个属性contents就是最终要绘制到手机屏幕上的一个位图，比如说是一个UILabel，那么contents中最终放的结果就是关于helloworld一个文字的位图，然后系统会在合适的时机回调给UIView的一个<code>drawRect</code>方法，让程序员在此基础之上去绘制自己一些想要的自定义绘制的内容。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-5c09a67006eaadab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>绘制好的位图最终会由<code>Core Animation</code>这个框架提交给GPU中的OpenGL(ES)渲染管线，进行最终的位图的渲染包括纹理的合成然后显示在手机屏幕上。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-e05246b24bf4a915.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIView的显示原理"></p>
<h2 id="CPU工作"><a href="#CPU工作" class="headerlink" title="CPU工作"></a>CPU工作</h2><table>
<thead>
<tr>
<th>Layout</th>
<th>Display(显示)</th>
<th>Prepare(准备)</th>
<th>commit</th>
</tr>
</thead>
<tbody>
<tr>
<td>UI布局、文本计算</td>
<td>绘制(drawRect)</td>
<td>图片编解码</td>
<td>提交位图</td>
</tr>
</tbody>
</table>
<h2 id="GPU渲染管线"><a href="#GPU渲染管线" class="headerlink" title="GPU渲染管线"></a>GPU渲染管线</h2><p>实际上即使OpenGL的渲染管线，这个过程：</p>
<ul>
<li>顶点着色(对位图的一个处理)</li>
<li>图元装配</li>
<li>光栅化</li>
<li>片段着色</li>
<li>片段处理</li>
</ul>
<p>做完以后，最终把像素点提交到<code>FrameBuffer</code>帧缓冲区中，由视频控制器在VSync信号到来之前去<code>FrameBuffer</code>帧缓冲区当中提取最终要显示在屏幕上的内容，这就构成了OpenGL的显示原理</p>
<h1 id="卡顿和掉帧"><a href="#卡顿和掉帧" class="headerlink" title="卡顿和掉帧"></a>卡顿和掉帧</h1><h2 id="UI卡顿和掉帧的原因"><a href="#UI卡顿和掉帧的原因" class="headerlink" title="UI卡顿和掉帧的原因"></a>UI卡顿和掉帧的原因</h2><p>一般来说页面滑动的流畅性是60FPS，指的就是每一秒钟会有60帧的画面更新，我们在人眼上面所看到的就是流畅的效果，那基于此每隔16.7ms(1/60)就要产生一帧的画面，那么在16.7ms之内需要CPU和GPU共同协同完成产生最终的一帧的数据。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-acd3f7604ecfdac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卡顿掉帧的原因.png"></p>
<p>比如说CPU花费一定的时间(文本的布局，UI的计算包括一些视图的绘制，以及图片解码然后最终得到的位图提交给GPU)，再由GPU进行相应的图层的合成、管理、渲染，准备好下一帧的画面，然后在下一帧的VSync信号到来的时候，就可以显示这个画面。</p>
<p>如果说CPU花费的时间特别长的话，那么留给GPU的时间就会减少，如果GPU进行相应的图层的合成、管理、渲染全部准备完毕可能就要总时间超过16.7ms，那么在下一帧VSync信号到来的时候<br>没有准备好这一帧的画面，那就由此产生掉帧，由此产生一个卡顿。</p>
<p>那么上述就可以总结UI卡顿掉帧的原因。</p>
<p>在规定的16.7ms之内在下一帧VSync到来之前并没有CPU和GPU共同完成下一帧画面的合成，于是就会造成卡顿掉帧。</p>
<h2 id="滑动优化方案"><a href="#滑动优化方案" class="headerlink" title="滑动优化方案"></a>滑动优化方案</h2><p>基于TableView和ScrollView都有哪些优化方案，你又是怎么样做的？</p>
<ul>
<li><p>CPU：减轻CPU所做的工作时长、包括它的压力来达到优化的效果。</p>
<ul>
<li>对象创建、调整、销毁放入子线程</li>
<li>预排版(布局计算、文本计算)放入到子线程去做</li>
<li>上述2个方式主线程就可以有更多的时间去响应用户的交互</li>
<li>预悬案(文本等异步绘制，图片编解码等)</li>
</ul>
</li>
<li><p>GPU</p>
<ul>
<li>纹理渲染(masksToBounds、圆角、阴影、蒙层都会涉及到GPU的离屏渲染)这样工作量就会加大基于这种情况我们就可以对GPU进行优化，可以依靠CPU的异步绘制来减轻GPU的离屏渲染压力。</li>
<li>视图混合(视图层级非常复杂，有多个视图层层叠加，那么GPU就要对这些视图进行合成，每一个像素点对应的像素值他需要做大量的计算，那么在一定程度上减轻视图层级的复杂性，那也可以减轻GPU的压力，也包括CPU的异步绘制来达到提交的位图本身就是层级少的视图，这样也可以减轻GPU的压力)。</li>
</ul>
</li>
</ul>
<h1 id="绘制原理和异步绘制"><a href="#绘制原理和异步绘制" class="headerlink" title="绘制原理和异步绘制"></a>绘制原理和异步绘制</h1><h2 id="UIView的绘制原理"><a href="#UIView的绘制原理" class="headerlink" title="UIView的绘制原理"></a>UIView的绘制原理</h2><p>当我们调用<code>[UIView setNeedsDisplay]</code>的时候，实际并没有立刻发生当前视图的绘制工作，而是在之后的某个时机才会进行当前UIView的绘制工作，基于这个问题，这是为什么？</p>
<ul>
<li>1、当调用这个方法<code>[UIView setNeedsDisplay]</code>这个方法</li>
<li>2、系统会自动调用<code>[view.layer setNeedsDisplay]</code>这个方法</li>
</ul>
<p>相当于在<code>view.layer</code>上面打上了一个标记，然后会在当前Runloop将要结束的时候调用<code>view.layer</code>的<code>[view.layer display]</code>然后才能进入到当前视图的真正的绘制工作。</p>
<p><code>[view.layer display]</code>中的方法会判断<code>view.layer.delegate</code>是否会响应<code>displaylayer</code>方法,假如不响应这个方法，就会进入到系统的绘制流程，<br>如果说<code>view.layer.delegate</code>响应<code>displaylayer</code>方法，那么就会进入到异步绘制入口。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-233a80f61767698e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIView绘制的原理过程.png"></p>
<h3 id="系统绘制的流程"><a href="#系统绘制的流程" class="headerlink" title="系统绘制的流程"></a>系统绘制的流程</h3><ul>
<li><p>在CAlayer内部会创建创建一个backingstore(CGContextRef)，我们可以通过<code>drawRect</code>方法中可以通过上下文堆栈当中取出栈顶的(context)CGContextRef,也可以说是backingstore，然后判断是否有代理：</p>
</li>
<li><p>如果没有代理会调用<code>[view.layer drawInContext:]</code>方法。</p>
</li>
<li>如果有代理会调用<code>view.layer.delegate drawLayer: inContext:</code>方法，做当前视图的绘制工作，这是系统内部做的事情，然后在合适的时间回调给我们方法<code>[view drawRect:]</code>。</li>
</ul>
<p><code>[view drawRect:]</code>默认是什么都不做，在系统的绘制的基础上再做其他的工作</p>
<p>无论是那种哪种方式最终都是CALayer来上传对应的backingstore到GPU，最后结束系统绘制的流程</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-1d8c64fbd2f24610.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统的绘制原理.png"></p>
<h2 id="如何实现异步绘制"><a href="#如何实现异步绘制" class="headerlink" title="如何实现异步绘制"></a>如何实现异步绘制</h2><p>异步绘制基于系统给开发者开放一个API<code>[view.layer.delegate displayLayer:]</code>，如果我们实现了<code>displayLayer:</code>的方法，就可以进入到异步绘制的一个流程中。</p>
<ul>
<li>代理负责生成对应的Bitmap位图</li>
<li>设置该bitmap作为layer.contents属性的值</li>
</ul>
<h3 id="原理流程"><a href="#原理流程" class="headerlink" title="原理流程"></a>原理流程</h3><ul>
<li>首先调用了<code>[view setNeedsDisplay]</code>的方法之后</li>
<li>在当前RunLoop将要结束的时候会由系统调用视图所对应layer的<code>[view.layer display]</code></li>
<li>如果我们实现了这个代理方法<code>displayLayer:</code>,会通过子线程的切换在子线程中去做一个位图的绘制，此时主线程可以做其他的操作<ul>
<li>子线程的主要工作</li>
<li>CGBitmapContextCreate   (core graphic的一个函数来创建一个位图的上下文)</li>
<li>CoreGraphic API 通过这个API可以做当前UI控件的一些绘制工作</li>
<li>CGBitmapContextCreateImage 通过这个函数来根据上下文生成一张cgimage的图片</li>
</ul>
</li>
<li>最后回到主队列，提交这个位图，设置当前视图的layer设置其<code>setContents</code>这样就完成了一个UI控件的异步绘制过程    </li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-c8bcd88540d875d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UI异步绘制的一个原理.png"></p>
<h1 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h1><p>什么是离屏渲染？你是怎么理解的？</p>
<ul>
<li><p>On-Screen Rendering</p>
<ul>
<li>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行的</li>
<li>在屏渲染是GPU层面中的一个概念</li>
</ul>
</li>
<li><p>Off-Screen Rendering</p>
<ul>
<li>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟的一个缓冲区进行渲染操作</li>
<li>离屏渲染起源于GPU上面</li>
</ul>
</li>
</ul>
<p>当我们指定了UI视图的某些属性，标记为在未预合成之前不能用于当前屏幕上直接显示的时候，就会触发离屏渲染。</p>
<h2 id="离屏渲染，何时会触发？"><a href="#离屏渲染，何时会触发？" class="headerlink" title="离屏渲染，何时会触发？"></a>离屏渲染，何时会触发？</h2><ul>
<li>圆角(同时要设置maskToBounds一起使用的时候才能触发)</li>
<li>图层蒙版</li>
<li>阴影</li>
<li>光栅化</li>
</ul>
<h2 id="为何要避免离屏渲染？"><a href="#为何要避免离屏渲染？" class="headerlink" title="为何要避免离屏渲染？"></a>为何要避免离屏渲染？</h2><p>触发离屏渲染的时候，会增加GPU的工作量，而增加了GPU的工作量很有可能导致了CPU和GPU工作耗时加起来的总耗时超出了16.7ms，那么就可能导致UI的卡顿和掉帧，所以我们需要比 main离屏渲染。</p>
<h1 id="系统的UI事件传递机制是怎么样的？"><a href="#系统的UI事件传递机制是怎么样的？" class="headerlink" title="系统的UI事件传递机制是怎么样的？"></a>系统的UI事件传递机制是怎么样的？</h1><p>hittest和PointInside的流程</p>
<h1 id="使UITableView滚动更流程的方案或思路都有哪些？"><a href="#使UITableView滚动更流程的方案或思路都有哪些？" class="headerlink" title="使UITableView滚动更流程的方案或思路都有哪些？"></a>使UITableView滚动更流程的方案或思路都有哪些？</h1><p>对于CPU在于子线程中对象的创建、调整和销毁、包括进行预排版以及图片的解码，采用异步绘制方案。这些都是对于UITableView滑动优化的方案</p>
<h1 id="什么是离屏渲染？"><a href="#什么是离屏渲染？" class="headerlink" title="什么是离屏渲染？"></a>什么是离屏渲染？</h1><p>离屏渲染起源于GPU，在当前屏幕缓冲区之外新开辟一个缓存区进行渲染操作就是离屏渲染，</p>
<h1 id="UIView和CALayer之间的关系是怎么样的？"><a href="#UIView和CALayer之间的关系是怎么样的？" class="headerlink" title="UIView和CALayer之间的关系是怎么样的？"></a>UIView和CALayer之间的关系是怎么样的？</h1><p>UIView是专门负责事件传递和视图响应的<br>而CALyaer全权负责视图的显示工作。</p>
<p><strong>为什么要区分UIView和CALayer的职责划分</strong></p>
<p>用到了六大设计原则的单一原则。</p>

      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/07/09/iOS晋级知识汇总(一)/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
    
<article id="post-iOS基础全面分析之四(动画全面分析)" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/07/iOS基础全面分析之四(动画全面分析)/">iOS基础全面分析之四(动画全面分析)</a>
    </h1>
  

        
        <a href="/2019/07/07/iOS基础全面分析之四(动画全面分析)/" class="archive-article-date">
  	<time datetime="2019-07-07T06:52:02.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-07-07</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="iOS动画"><a href="#iOS动画" class="headerlink" title="iOS动画"></a>iOS动画</h1><p>好的应用都有一个共同的特点，那就是良好的用户体验，动画作为提升用户体验一个重要技术，在开发人员和产品设计人员手里，则应该受到足够重视。</p>
<p>CoreGraphics(核心图形)、QuartzCore、CoreAnimation(核心动画)</p>
<ul>
<li><p>CoreGraphics(核心图形)</p>
<ul>
<li>它是iOS的核心图形库，包含Quartz2D绘图API接口,常用的是point，size，rect等这些图形，都定义在这个框架中，类名以CG开头的都属于CoreGraphics框架，它提供的都是C语言函数接口，是可以在iOS和mac OS 通用的</li>
</ul>
</li>
<li><p>QuartzCore</p>
<ul>
<li>Quartz是位于Mac OS X的Drawin核心之上的绘图层，这个框架感觉不是很清晰，但是看头文件可以发现，它就是CoreAnimation，这个框架头文件只包含了CoreAnimation.h</li>
<li>是iOS系统的基本渲染框架，是一个OC语言框架，是一套基于CoreGraphics的OC语言封装，封装出了基本渲染类CALayer</li>
</ul>
</li>
</ul>
<p>CoreAnimation(核心动画)</p>
<pre><code>- CoreAnimation翻译过来就是核心动画,一组非常强大的API，用来做动画的，非常的简单，但是效果非常绚丽
- CoreAnimation是跨平台的，既可以支持IOS，也支持MAC OS
- CoreAnimation执行动画是在后台，不会阻塞主线程
- CoreAnimation作用在CALayer，不是UIView
</code></pre><h2 id="Core-animation-核心动画"><a href="#Core-animation-核心动画" class="headerlink" title="Core animation(核心动画)"></a>Core animation(核心动画)</h2><h2 id="锚点anchorPoint"><a href="#锚点anchorPoint" class="headerlink" title="锚点anchorPoint"></a>锚点anchorPoint</h2><ul>
<li>概念<ul>
<li>anchorPoint是相对于自身layer，anchorPoint点(锚点)的值是用相对bounds的比例值来确定的。</li>
<li>anchorPoint相当于支点，可以用作旋转变化、平移、缩放，如果修改anchorPoint则layer的frame会发生改变，position不会发生改变.</li>
<li>修改position与anchorPoint中任何一个属性都不影响另一个属性.</li>
</ul>
</li>
<li>单位：<ul>
<li>0～1</li>
</ul>
</li>
<li>anchorPoint和position的关系<ul>
<li>anchorPoint和position不是一个点</li>
</ul>
</li>
<li>anchorPoint和position和frame的三条关系<ul>
<li>第一条关系说明：锚点不变时，frame改变，position会随着变化</li>
<li>第二条关系说明：锚点不变时，position变化，frame会随着变化</li>
<li>第三条关系说明：锚点改变， position不影响，frame会随着变化</li>
</ul>
</li>
</ul>
<h3 id="创建动画的三个步骤"><a href="#创建动画的三个步骤" class="headerlink" title="创建动画的三个步骤"></a>创建动画的三个步骤</h3><ul>
<li>创建核心动画大致分为三个步骤：<ol>
<li>初始化动画对象</li>
<li>设置需要修改动画的属性值</li>
<li>把动画添加到layer上</li>
</ol>
</li>
</ul>
<h3 id="隐式动画和显示动画"><a href="#隐式动画和显示动画" class="headerlink" title="隐式动画和显示动画"></a>隐式动画和显示动画</h3><p>当动画完成以后你看到的都是假象，你的view并没有变化，layer分为两层：</p>
<ul>
<li>presentationlayer  呈现成<ul>
<li>凡是眼睛看到的都是呈现层</li>
</ul>
</li>
<li>modelayer          模型层<ul>
<li>用来存储数据，等到屏幕需要刷新的时候绘制到呈现层</li>
</ul>
</li>
</ul>
<h4 id="显示动画"><a href="#显示动画" class="headerlink" title="显示动画"></a>显示动画</h4><ul>
<li>通过自定义三步骤的动画都是显示动画</li>
</ul>
<h4 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h4><ul>
<li>通过自创建的layer，修改其属性会默认添加一些动画效果，这些动画效果就是隐式动画<ul>
<li>CALayer 默认时间 0.25s(位置、颜色、大小)</li>
<li>必须是独立的CALayer才有隐式动画， UIView的根layer是没有的</li>
</ul>
</li>
</ul>
<p>例如代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_layer = [CALayer layer];</span><br><span class="line">_layer.frame = CGRectMake(200, 100, 100, 100);</span><br><span class="line">//可移值性</span><br><span class="line">_layer.backgroundColor = [UIColor yellowColor].CGColor;</span><br><span class="line">[self.view.layer addSublayer:_layer];</span><br><span class="line"></span><br><span class="line">_layer.frame = CGRectMake(200, 400, 100, 100);</span><br></pre></td></tr></table></figure>
<h3 id="iOS动画框架结构"><a href="#iOS动画框架结构" class="headerlink" title="iOS动画框架结构"></a>iOS动画框架结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-893a5e6307a7c32a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="CoreAnimation.png"></p>
<p>在iOS系统中给我们提供了基于<code>Core animation</code>这几种动画，如下图所示:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-bbae2e6566e2f554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="CABasicAnimation-基本动画"><a href="#CABasicAnimation-基本动画" class="headerlink" title="CABasicAnimation(基本动画)"></a>CABasicAnimation(基本动画)</h3><h4 id="CABasicAnimation的属性"><a href="#CABasicAnimation的属性" class="headerlink" title="CABasicAnimation的属性"></a>CABasicAnimation的属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>duration</td>
<td>动画的时长</td>
</tr>
<tr>
<td>repeatCount</td>
<td>重复的次数</td>
</tr>
<tr>
<td>repeatDuration</td>
<td>设置动画的时间，在改时间内一直执行，不计算次数</td>
</tr>
<tr>
<td>beginTime</td>
<td>指定动画开始时间</td>
</tr>
<tr>
<td>timingFunction</td>
<td>设置动画的速度变化</td>
</tr>
<tr>
<td>autoreverses</td>
<td>动画结束是否执行逆动画</td>
</tr>
<tr>
<td>fromValue</td>
<td>属性的起始值</td>
</tr>
<tr>
<td>toValue</td>
<td>结束的值</td>
</tr>
<tr>
<td>byValue</td>
<td>改变属性相同起始值的改变量</td>
</tr>
</tbody>
</table>
<h4 id="CABasicAnimation的Keypath属性"><a href="#CABasicAnimation的Keypath属性" class="headerlink" title="CABasicAnimation的Keypath属性"></a>CABasicAnimation的Keypath属性</h4><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/AnimatableProperties/AnimatableProperties.html" target="_blank" rel="noopener">apple官网动画属性</a></p>
<p>如下常用的属性：</p>
<table>
<thead>
<tr>
<th>Keypath</th>
<th>说明</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>transform.scale</td>
<td>比例转化</td>
<td>@(cgfloat)</td>
</tr>
<tr>
<td>transform.scale.x</td>
<td>宽的比例</td>
<td>@(cgfloat)</td>
</tr>
<tr>
<td>transform.scale.y</td>
<td>高的比例</td>
<td>@(cgfloat)</td>
</tr>
<tr>
<td>transform.rotation.x</td>
<td>围绕x轴旋转</td>
<td>@(M_PI)</td>
</tr>
<tr>
<td>transform.rotation.y</td>
<td>围绕y轴旋转</td>
<td>@(M_PI)</td>
</tr>
<tr>
<td>transform.rotation.z</td>
<td>围绕z轴旋转</td>
<td>@(M_PI)</td>
</tr>
<tr>
<td>cornerRadius</td>
<td>圆角的设置</td>
<td>@(50)</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>背景颜色的变化</td>
<td>(id)[uicolor redcolor].cgcolor</td>
</tr>
<tr>
<td>bounds</td>
<td>大小，中心不变</td>
<td>[nsvalue valuewithcgrect:]</td>
</tr>
<tr>
<td>position</td>
<td>位置(中心点的改变)</td>
<td>[nsvalue valuewithcgpoint]</td>
</tr>
<tr>
<td>contents</td>
<td>内容(比如图片)</td>
<td>(id)image.cgimage</td>
</tr>
<tr>
<td>opacity</td>
<td>透明度</td>
<td>@(cgfloat)</td>
</tr>
<tr>
<td>contentsRect.size.width</td>
<td>横向拉伸缩放(需要设置contents)</td>
<td>@(cgfloat)</td>
</tr>
</tbody>
</table>
<h4 id="CABasicAnimation的例子"><a href="#CABasicAnimation的例子" class="headerlink" title="CABasicAnimation的例子"></a>CABasicAnimation的例子</h4><p>做一个从上往下走的动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *basicani = [CABasicAnimation animationWithKeyPath:@&quot;position.y&quot;];//中心点</span><br><span class="line">basicani.toValue = @400;</span><br><span class="line">basicani.duration = 2;</span><br><span class="line">//动画完成不移除状态</span><br><span class="line">basicani.removedOnCompletion = NO;</span><br><span class="line">//保持最后的状态</span><br><span class="line">basicani.fillMode = kCAFillModeForwards;</span><br><span class="line">basicani.delegate = self;</span><br><span class="line">[_RedView.layer addAnimation:basicani forKey:@&quot;&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="CAKeyframeAnimation关键帧动画"><a href="#CAKeyframeAnimation关键帧动画" class="headerlink" title="CAKeyframeAnimation关键帧动画"></a>CAKeyframeAnimation关键帧动画</h3><p>CAKeyframeAnimation设置动画的路径分为两种</p>
<ol>
<li>设置path</li>
<li>设置一组的values</li>
</ol>
<h4 id="CAKeyframeAnimation的例子"><a href="#CAKeyframeAnimation的例子" class="headerlink" title="CAKeyframeAnimation的例子"></a>CAKeyframeAnimation的例子</h4><p>代码如下：设置了一个飞机按照轨迹飞行的动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//贝塞尔曲线</span><br><span class="line">/*</span><br><span class="line"> 想要通过程序写曲线或者不规则的图形时，是很复杂的</span><br><span class="line"> 贝塞尔曲线就是通过代码转换成公式来进行绘制的。</span><br><span class="line"> </span><br><span class="line"> 起点</span><br><span class="line"> 终点</span><br><span class="line"> 2个控制点</span><br><span class="line"> **/</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">[path moveToPoint:CGPointMake(20, 200)];</span><br><span class="line">[path addCurveToPoint:CGPointMake(300, 200) controlPoint1:CGPointMake(100, 100) controlPoint2:CGPointMake(200, 300)];</span><br><span class="line">    </span><br><span class="line">CALayer *planelayer = [CALayer layer];</span><br><span class="line">planelayer.backgroundColor = [UIColor redColor].CGColor;</span><br><span class="line">planelayer.frame = CGRectMake(0, 0, 40, 40);</span><br><span class="line">planelayer.anchorPoint = CGPointMake(0.5, 0.8);</span><br><span class="line">planelayer.contents = (id)[UIImage imageNamed:@&quot;feiji&quot;].CGImage;</span><br><span class="line">[self.view.layer addSublayer:planelayer];</span><br><span class="line">    </span><br><span class="line">//需要添加到layer上</span><br><span class="line">//形状图 矢量图 这个事layer的子类，CAShapeLayer有一个硬件加速更快</span><br><span class="line">CAShapeLayer *shapelayer = [CAShapeLayer layer];</span><br><span class="line">shapelayer.path = path.CGPath;</span><br><span class="line">shapelayer.fillColor = nil;  //填充颜色</span><br><span class="line">shapelayer.strokeColor = [UIColor blueColor].CGColor;//画笔的颜色</span><br><span class="line">[self.view.layer addSublayer:shapelayer];</span><br><span class="line">    </span><br><span class="line">/*</span><br><span class="line"> CAKeyframeAnimation 设置动画的路径分为两种：</span><br><span class="line"> 1. 设置path</span><br><span class="line"> 2. 设置一组values</span><br><span class="line"> ***/</span><br><span class="line">    </span><br><span class="line">//飞行动画</span><br><span class="line">CAKeyframeAnimation *planeAni = [CAKeyframeAnimation animation];</span><br><span class="line">planeAni.keyPath = @&quot;position&quot;;</span><br><span class="line">planeAni.path = path.CGPath;</span><br><span class="line">planeAni.rotationMode = kCAAnimationRotateAuto;</span><br><span class="line">planeAni.duration = 3.5;</span><br><span class="line">planeAni.fillMode = kCAFillModeForwards;</span><br><span class="line">planeAni.removedOnCompletion = NO;</span><br><span class="line">[planelayer addAnimation:planeAni forKey:@&quot;planeAni&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="CAAnimationGroup动画组"><a href="#CAAnimationGroup动画组" class="headerlink" title="CAAnimationGroup动画组"></a>CAAnimationGroup动画组</h3><p>将多个动画合并到一起的动画就是CAAnimationGroup动画组</p>
<h4 id="CAAnimationGroup例子"><a href="#CAAnimationGroup例子" class="headerlink" title="CAAnimationGroup例子"></a>CAAnimationGroup例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">[path moveToPoint:CGPointMake(20, 200)];</span><br><span class="line">[path addCurveToPoint:CGPointMake(300, 200) controlPoint1:CGPointMake(100, 100) controlPoint2:CGPointMake(200, 300)];</span><br><span class="line">    </span><br><span class="line">CALayer *colorlayer = [CALayer layer];</span><br><span class="line">colorlayer.frame = CGRectMake(0, 0, 60, 60);</span><br><span class="line">colorlayer.position = CGPointMake(50, 200);</span><br><span class="line">colorlayer.backgroundColor = [UIColor yellowColor].CGColor;</span><br><span class="line">[self.view.layer addSublayer:colorlayer];</span><br><span class="line"></span><br><span class="line">//飞行动画</span><br><span class="line">CAKeyframeAnimation *planeAni = [CAKeyframeAnimation animation];</span><br><span class="line">planeAni.keyPath = @&quot;position&quot;;</span><br><span class="line">planeAni.path = path.CGPath;</span><br><span class="line">planeAni.rotationMode = kCAAnimationRotateAuto;</span><br><span class="line">    </span><br><span class="line">//改变大小</span><br><span class="line">CABasicAnimation *sizeanim = [CABasicAnimation animation];</span><br><span class="line">sizeanim.keyPath = @&quot;transform.scale&quot;;</span><br><span class="line">sizeanim.toValue = @0.5;</span><br><span class="line"></span><br><span class="line">//改变颜色</span><br><span class="line">CGFloat redcolor = arc4random() % 255 / 255.0f;</span><br><span class="line">CGFloat greencolor = arc4random() % 255 / 255.0f;</span><br><span class="line">CGFloat bluecolor = arc4random() % 255 / 255.0f ;</span><br><span class="line">UIColor *color = [UIColor colorWithRed:redcolor green:greencolor blue:bluecolor alpha:1];</span><br><span class="line">    </span><br><span class="line">CABasicAnimation *colorAnim = [CABasicAnimation animation];</span><br><span class="line">colorAnim.keyPath = @&quot;backgroundColor&quot;;</span><br><span class="line">colorAnim.toValue = (id)color.CGColor;</span><br><span class="line">    </span><br><span class="line">CAAnimationGroup *group = [CAAnimationGroup animation];</span><br><span class="line">group.animations = @[planeAni, sizeanim, colorAnim];</span><br><span class="line">group.duration = 4.0f;</span><br><span class="line">group.fillMode = kCAFillModeForwards;</span><br><span class="line">group.removedOnCompletion = NO;</span><br><span class="line">[colorlayer addAnimation:group forKey:nil];</span><br></pre></td></tr></table></figure>
<h2 id="转场动画"><a href="#转场动画" class="headerlink" title="转场动画"></a>转场动画</h2><h3 id="CATransition转场动画"><a href="#CATransition转场动画" class="headerlink" title="CATransition转场动画"></a>CATransition转场动画</h3><p>CATransition是CAAnimation的子类，用于过渡动画或转场动画。为视图层移入移除屏幕提供转场动画。</p>
<p>简单的转场动画ImageView的切换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UIImageView *ImageView;</span><br><span class="line">@property (strong,nonatomic)NSArray *images;</span><br><span class="line">@property (assign,nonatomic)NSInteger index;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)Createtransition&#123;</span><br><span class="line">    </span><br><span class="line">    if(_index == 3)&#123;</span><br><span class="line">        _index = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    _index ++ ;</span><br><span class="line">    NSString *imagename = _images[_index];</span><br><span class="line">    _ImageView.image = [UIImage imageNamed:imagename];</span><br><span class="line">    CATransition *anima = [CATransition animation];</span><br><span class="line">    anima.type = @&quot;cube&quot;;</span><br><span class="line">    [_ImageView.layer addAnimation:anima forKey:@&quot;CATransitionkey&quot;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">_images = @[@&quot;1.jpg&quot;,@&quot;2.jpg&quot;,@&quot;3.jpg&quot;,@&quot;4.jpg&quot;];</span><br><span class="line">_index = 0;</span><br><span class="line"></span><br><span class="line">[self Createtransition];</span><br></pre></td></tr></table></figure>
<h4 id="转场动画的重要属性"><a href="#转场动画的重要属性" class="headerlink" title="转场动画的重要属性"></a>转场动画的重要属性</h4><ul>
<li><p>type：系统自带转场动画的类型</p>
<ul>
<li><p>官方自定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CA_EXTERN NSString * const kCATransitionFade;</span><br><span class="line">CA_EXTERN NSString * const kCATransitionMoveIn;</span><br><span class="line">CA_EXTERN NSString * const kCATransitionPush;</span><br><span class="line">CA_EXTERN NSString * const kCATransitionReveal;</span><br></pre></td></tr></table></figure>
</li>
<li><p>私有的type：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString *const kCATransitionCube = @&quot;cube&quot;; </span><br><span class="line">NSString *const kCATransitionSuckEffect = @&quot;suckEffect&quot;; </span><br><span class="line">NSString *const kCATransitionOglFlip = @&quot;oglFlip&quot;; </span><br><span class="line">NSString *const kCATransitionRippleEffect = @&quot;rippleEffect&quot;; </span><br><span class="line">NSString *const kCATransitionPageCurl = @&quot;pageCurl&quot;; </span><br><span class="line">NSString *const kCATransitionPageUnCurl = @&quot;pageUnCurl&quot;; </span><br><span class="line">NSString *const kCATransitionCameraIrisHollowOpen = @&quot;cameraIrisHollowOpen&quot;;</span><br><span class="line">NSString *const kCATransitionCameraIrisHollowClose = @&quot;cameraIrisHollowClose&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>subtype:动画类型的方向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CA_EXTERN NSString * const kCATransitionFromRight;</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromLeft;</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromTop;</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromBottom;</span><br></pre></td></tr></table></figure>
<h3 id="transitionFromViewController"><a href="#transitionFromViewController" class="headerlink" title="transitionFromViewController"></a>transitionFromViewController</h3><h4 id="转场动画的type"><a href="#转场动画的type" class="headerlink" title="转场动画的type"></a>转场动画的type</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIViewAnimationOptionTransitionNone            = 0 &lt;&lt; 20, // default</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromLeft    = 1 &lt;&lt; 20,</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromRight   = 2 &lt;&lt; 20,</span><br><span class="line">UIViewAnimationOptionTransitionCurlUp          = 3 &lt;&lt; 20,</span><br><span class="line">UIViewAnimationOptionTransitionCurlDown        = 4 &lt;&lt; 20,</span><br><span class="line">UIViewAnimationOptionTransitionCrossDissolve   = 5 &lt;&lt; 20,</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromTop     = 6 &lt;&lt; 20,</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromBottom  = 7 &lt;&lt; 20,</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AViewController *a = self.childViewControllers[0];</span><br><span class="line">BViewController *b = self.childViewControllers[1];</span><br><span class="line">CViewController *c = self.childViewControllers[2];</span><br><span class="line"></span><br><span class="line">[self transitionFromViewController:_currentViewController</span><br><span class="line">                  toViewController:b</span><br><span class="line">                          duration:0.5</span><br><span class="line">                           options:UIViewAnimationOptionTransitionFlipFromRight</span><br><span class="line">                        animations:^&#123;</span><br><span class="line"></span><br><span class="line">&#125; completion:^(BOOL finished) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="Transition-Animation-自定义转场动画"><a href="#Transition-Animation-自定义转场动画" class="headerlink" title="Transition Animation(自定义转场动画)"></a>Transition Animation(自定义转场动画)</h3><p><strong>第一种：presented&amp; Dismiss</strong><br>需要实现<code>UIViewController</code>中的<code>UIViewControllerTransitioningDelegate</code>协议，实现下面两个API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//presented会调用的方法</span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;) v:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;</span><br><span class="line">//Dismiss会调用的方法</span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed</span><br></pre></td></tr></table></figure>
<p><strong>第二种：Push&amp;Pop</strong></p>
<p>需要实现<code>navigationController</code>中的<code>UINavigationControllerDelegate</code>协议，实现下面一个API:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</span><br><span class="line">                                            animationControllerForOperation:(UINavigationControllerOperation)operation</span><br><span class="line">                                                         fromViewController:(UIViewController *)fromVC</span><br><span class="line">                                                           toViewController:(UIViewController *)toVC&#123;</span><br></pre></td></tr></table></figure>
<p>上述API的返回值<code>id &lt;UIViewControllerAnimatedTransitioning&gt;</code>就是我们需要自定义的动画</p>
<ul>
<li><p>自定义转场动画步骤：</p>
<ol>
<li>创建一个<code>NSObject</code>的对象</li>
<li>核心：遵守<code>&lt;UIViewControllerAnimatedTransitioning&gt;</code></li>
<li><p>实现下面2个方法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//动画持续时间，单位是秒</span><br><span class="line">- (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//动画效果</span><br><span class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>animateTransition</code>方法中实现你的动画</p>
</li>
<li>动画结束后调用<code>completeTransition</code>告诉系统转场动画结束</li>
</ol>
</li>
<li><p>自定义转场动画的核心思想</p>
<ul>
<li>containerView 动画的容器</li>
<li>ToVC</li>
<li>FromVC</li>
<li>mask</li>
<li>completeTransition动画完成</li>
</ul>
</li>
</ul>
<h4 id="Push-amp-Pop形式转场动画"><a href="#Push-amp-Pop形式转场动画" class="headerlink" title="Push&amp;Pop形式转场动画"></a>Push&amp;Pop形式转场动画</h4><ul>
<li><p>自定义转场动画入口:</p>
<ol>
<li>在Push和Pop的<code>ViewController</code>遵守<code>UINavigationControllerDelegate</code>协议</li>
<li><p>实现下面方法,并返回自定义动画：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</span><br><span class="line">                                            animationControllerForOperation:(UINavigationControllerOperation)operation</span><br><span class="line">                                                         fromViewController:(UIViewController *)fromVC</span><br><span class="line">                                                           toViewController:(UIViewController *)toVC&#123;</span><br><span class="line">    </span><br><span class="line">    if(operation == UINavigationControllerOperationPush)&#123;</span><br><span class="line">    	//Push</span><br><span class="line">    	return 返回你的自定义动画</span><br><span class="line">    &#125;</span><br><span class="line">    if(operation == UINavigationControllerOperationPop)&#123;</span><br><span class="line">    	//Pop</span><br><span class="line">    	return 返回你的自定义动画</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ul>
<li>自定义转场动画实现代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//Pop</span><br><span class="line">- (void)CreatePopAnimation:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123;</span><br><span class="line">    </span><br><span class="line">    UIViewController * fromVC   = [_context viewControllerForKey:UITransitionContextFromViewControllerKey];</span><br><span class="line">    UIViewController *toVC      = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    UIView *containerView       = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:toVC.view];</span><br><span class="line">    [containerView addSubview:fromVC.view];</span><br><span class="line"></span><br><span class="line">    maskLayer.path              = SmallPath.CGPath;</span><br><span class="line">    fromVC.view.layer.mask      = maskLayer;</span><br><span class="line">    </span><br><span class="line">    CABasicAnimation *anim      = [CABasicAnimation animation];</span><br><span class="line">    anim.keyPath                = @&quot;path&quot;;</span><br><span class="line">    anim.fromValue              = (__bridge id _Nullable)(BigPath.CGPath);</span><br><span class="line">    anim.toValue                = (__bridge id)(SmallPath.CGPath);</span><br><span class="line">    anim.duration               = [self transitionDuration:_context];</span><br><span class="line">    anim.timingFunction         = [CAMediaTimingFunction  functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    anim.delegate               = self;</span><br><span class="line">    [maskLayer addAnimation:anim forKey:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//push</span><br><span class="line">- (void)CreatePushAnimation:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123;</span><br><span class="line">    </span><br><span class="line">    UIViewController *toVC      = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    UIView *containerView       = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:toVC.view];</span><br><span class="line"></span><br><span class="line">    maskLayer.path              = BigPath.CGPath;</span><br><span class="line">    toVC.view.layer.mask        = maskLayer;</span><br><span class="line"></span><br><span class="line">    CABasicAnimation *anim      = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</span><br><span class="line">    anim.fromValue              = (__bridge id)(SmallPath.CGPath);</span><br><span class="line">    anim.toValue                = (__bridge id)((BigPath.CGPath));</span><br><span class="line">    anim.duration               = [self transitionDuration:_context];</span><br><span class="line">    anim.timingFunction         = [CAMediaTimingFunction  functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    anim.delegate               = self;</span><br><span class="line">    [maskLayer addAnimation:anim forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Presentation-amp-Dismiss形式转场动画"><a href="#Presentation-amp-Dismiss形式转场动画" class="headerlink" title="Presentation&amp;Dismiss形式转场动画"></a>Presentation&amp;Dismiss形式转场动画</h4><ul>
<li><p>自定义转场动画入口:</p>
<ol>
<li>present后的视图<code>ToVC</code>遵守<code>UIViewControllerTransitioningDelegate</code>协议<ul>
<li>self.transitioningDelegate = self;</li>
<li>self.modalPresentationStyle = UIModalPresentationCustom;</li>
</ul>
</li>
<li><p>实现下面方法,并返回自定义动画：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ul>
<li>自定义动画代码实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//dissmiss</span><br><span class="line">- (void)CreateDismissAnimation:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123;</span><br><span class="line">    </span><br><span class="line">    UIView* containerView   = [transitionContext containerView];</span><br><span class="line">    TwoVC * fromVC          = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</span><br><span class="line">     [containerView addSubview:fromVC.view];</span><br><span class="line">    </span><br><span class="line">    maskLayer.path              = SmallPath.CGPath;</span><br><span class="line">    fromVC.view.layer.mask      = maskLayer;</span><br><span class="line"></span><br><span class="line">    CABasicAnimation *anim      = [CABasicAnimation animation];</span><br><span class="line">    anim.keyPath                = @&quot;path&quot;;</span><br><span class="line">    anim.fromValue              = (__bridge id _Nullable)(BigPath.CGPath);</span><br><span class="line">    anim.toValue                = (__bridge id _Nullable)(SmallPath.CGPath);</span><br><span class="line">    anim.duration               = [self transitionDuration:_context];</span><br><span class="line">    anim.timingFunction         = [CAMediaTimingFunction  functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    anim.delegate               = self;</span><br><span class="line">    [maskLayer addAnimation:anim forKey:nil];</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Presentation</span><br><span class="line">- (void)CreatePresentationAnimation:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123;</span><br><span class="line">    </span><br><span class="line">    UIViewController *toVC      = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    toVC.view.frame             = CGRectMake(0, 0, GGScreenwidth, GGScreenheight);</span><br><span class="line">    UIView *containerView       = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:toVC.view];</span><br><span class="line">    </span><br><span class="line">    maskLayer.path              = BigPath.CGPath;</span><br><span class="line">    toVC.view.layer.mask        = maskLayer;</span><br><span class="line"></span><br><span class="line">    CABasicAnimation *anim      = [CABasicAnimation animation];</span><br><span class="line">    anim.keyPath                = @&quot;path&quot;;</span><br><span class="line">    anim.fromValue              = (__bridge id _Nullable)(SmallPath.CGPath);</span><br><span class="line">    anim.toValue                = (__bridge id _Nullable)(BigPath.CGPath);</span><br><span class="line">    anim.duration               = [self transitionDuration:_context];</span><br><span class="line">    anim.timingFunction         = [CAMediaTimingFunction  functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    anim.delegate               = self;</span><br><span class="line">    [maskLayer addAnimation:anim forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/GanggangGao/TransitionDemo" target="_blank" rel="noopener">转场动画代码</a></p>
<p>转场效果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-bdc887e7812fc6f2.gif?imageMogr2/auto-orient/strip" alt=""></p>

      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/07/07/iOS基础全面分析之四(动画全面分析)/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
    
<article id="post-深入浅出iOS多线程(四)——NSOperation多线程" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/02/深入浅出iOS多线程(四)——NSOperation多线程/">深入浅出iOS多线程(四)——NSOperation多线程</a>
    </h1>
  

        
        <a href="/2019/07/02/深入浅出iOS多线程(四)——NSOperation多线程/" class="archive-article-date">
  	<time datetime="2019-07-02T14:08:24.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-07-02</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="NSOperation的作用"><a href="#NSOperation的作用" class="headerlink" title="NSOperation的作用"></a>NSOperation的作用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>和GCD一样，NSOperation也是并发编程技术，NSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD更高一层的封装,比GCD更加简单，更加方便</p>
<p>NSoperation需要配合NSOperationQueue来实现多线程，NSOperation单独使用时系统同步执行操作，并没有开辟新的线程的能力，只有配合NSoperationQueue才能实现异步执行。</p>
<p>NSOperation是苹果大力推荐的”并发”技术<br>NSOperation的核心概念是，将”操作”添加进”队列”<br>GCD将”任务”添加到”队列”</p>
<ul>
<li>NSOperation是一个抽象类<ul>
<li>特点：不能直接使用</li>
<li>目的：定义子类共有的属性和方法</li>
<li>子类：NSInvocationOperation、NSBlockOperation</li>
</ul>
</li>
</ul>
<p>由于NSOperation是基于GCD的，使用步骤也和GCD差不多，其中，NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列，NSOperation实现多线程的使用步骤分3步：</p>
<ul>
<li>创建操作：创建<code>NSOperation</code>子类对象</li>
<li>创建队列：创建<code>NSOperationQueue</code>队列</li>
<li>将操作添加到队列中去：<code>NSOperation</code>添加到<code>NSOperationQueue</code>中去</li>
</ul>
<p>系统会自动取出”队列”中的”操作”执行。</p>
<h2 id="NSOperation多线程的基本使用"><a href="#NSOperation多线程的基本使用" class="headerlink" title="NSOperation多线程的基本使用"></a>NSOperation多线程的基本使用</h2><h3 id="NSInvocationOperation的基本使用"><a href="#NSInvocationOperation的基本使用" class="headerlink" title="NSInvocationOperation的基本使用"></a>NSInvocationOperation的基本使用</h3><ul>
<li><p>将NSOperation添加到队列，会自动异步执行调度方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSInvocationOperation * op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(downloadImage:) object:@&quot;invocation&quot;];</span><br><span class="line">NSOperationQueue * q = [[NSOperationQueue alloc]init];</span><br><span class="line">[q addOperation:op];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>打印结果</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NSThread: 0x600001f536c0&gt;&#123;number = 3, name = (null)&#125;  invocation</span><br></pre></td></tr></table></figure>
</li>
<li><p>将NSOperation添加到队列，会自动异步执行调度方法</p>
</li>
</ul>
<p>根据上述代码我们可以确信<code>NSOperationQueue</code>是一个队列，而<code>NSInvocationOperation</code>是一个操作(任务)，那么这个队列到底是什么样的队列，而这个操作是什么样的操作，在上述代码中队列添加更多的”操作”，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//队列</span><br><span class="line">NSOperationQueue * q = [[NSOperationQueue alloc]init];</span><br><span class="line">	</span><br><span class="line">for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">    NSInvocationOperation * op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(downloadImage:) object:@(i)];</span><br><span class="line">    //将操作添加到队列 - 会自动异步执行调度方法</span><br><span class="line">    [q addOperation:op];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;NSThread: 0x6000016c8cc0&gt;&#123;number = 4, name = (null)&#125;  1</span><br><span class="line">&lt;NSThread: 0x6000016f4140&gt;&#123;number = 3, name = (null)&#125;  0</span><br><span class="line">&lt;NSThread: 0x6000016c0a00&gt;&#123;number = 6, name = (null)&#125;  3</span><br><span class="line">&lt;NSThread: 0x6000016cc380&gt;&#123;number = 5, name = (null)&#125;  2</span><br><span class="line">&lt;NSThread: 0x6000016f4280&gt;&#123;number = 7, name = (null)&#125;  4</span><br><span class="line">&lt;NSThread: 0x6000016f4140&gt;&#123;number = 3, name = (null)&#125;  8</span><br><span class="line">&lt;NSThread: 0x6000016cc380&gt;&#123;number = 5, name = (null)&#125;  6</span><br><span class="line">&lt;NSThread: 0x6000016c0a00&gt;&#123;number = 6, name = (null)&#125;  7</span><br><span class="line">&lt;NSThread: 0x6000016c8cc0&gt;&#123;number = 4, name = (null)&#125;  5</span><br><span class="line">&lt;NSThread: 0x6000016f4280&gt;&#123;number = 7, name = (null)&#125;  9</span><br></pre></td></tr></table></figure>
<p>从打印结果上面看，线程不一样，执行顺序也不一样，说明这个队列是并发队列，队列中的操作是异步操作。</p>
<h3 id="NSBlockOperation的基本使用"><a href="#NSBlockOperation的基本使用" class="headerlink" title="NSBlockOperation的基本使用"></a>NSBlockOperation的基本使用</h3><p><code>NSBlockOperation</code>跟<code>NSInvocationOperation</code>使用步骤几乎一摸一样，不一样的地方在于，<code>NSBlockOperation</code>比<code>NSInvocationOperation</code>省略了一个@selector，代码更加简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">	第一种block形式</span><br><span class="line">**/</span><br><span class="line">//1.队列</span><br><span class="line">NSOperationQueue * q = [[NSOperationQueue alloc]init];</span><br><span class="line">    </span><br><span class="line">//2.操作</span><br><span class="line">for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">    NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    	 [NSThread currentThread].name = [@(i) stringValue];</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    //将操作添加到队列 - 会自动异步执行调度方法</span><br><span class="line">    [q addOperation:op];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	第一种block形式</span><br><span class="line">**/</span><br><span class="line">//1.队列</span><br><span class="line">NSOperationQueue * q = [[NSOperationQueue alloc]init];</span><br><span class="line">    </span><br><span class="line">//2.操作</span><br><span class="line">for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">    //将操作添加到队列 - 会自动异步执行调度方法</span><br><span class="line">    [q addOperationWithBlock:^&#123;</span><br><span class="line">    	 [NSThread currentThread].name = [@(i) stringValue];</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;NSThread: 0x6000001e1900&gt;&#123;number = 5, name = 1&#125;</span><br><span class="line">&lt;NSThread: 0x6000001e1940&gt;&#123;number = 6, name = 3&#125;</span><br><span class="line">&lt;NSThread: 0x6000001ea900&gt;&#123;number = 3, name = 0&#125;</span><br><span class="line">&lt;NSThread: 0x6000001e16c0&gt;&#123;number = 4, name = 2&#125;</span><br><span class="line">&lt;NSThread: 0x6000001ea900&gt;&#123;number = 3, name = 5&#125;</span><br><span class="line">&lt;NSThread: 0x6000001e1940&gt;&#123;number = 6, name = 4&#125;</span><br><span class="line">&lt;NSThread: 0x6000001e1900&gt;&#123;number = 5, name = 6&#125;</span><br><span class="line">&lt;NSThread: 0x6000001e16c0&gt;&#123;number = 4, name = 7&#125;</span><br><span class="line">&lt;NSThread: 0x6000001eaf40&gt;&#123;number = 7, name = 8&#125;</span><br><span class="line">&lt;NSThread: 0x6000001ea900&gt;&#123;number = 3, name = 9&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行结果，同样可以知道这个队列是并发队列，队列中的操作是异步操作。</p>
<p>上述代码，所有的代码都要添加一个队列怎么办？  </p>
<ul>
<li>在<code>self</code>中定义一个类属性，在配合懒加载的形式，这样的话不管这个类中哪个方法有添加队列的操作，那么都可以使用这一个”队列”，这样会让代码更加简洁。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic,strong)NSOperationQueue * MyQueue;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (NSOperationQueue *)MyQueue&#123;</span><br><span class="line">    </span><br><span class="line">    if(!_MyQueue)&#123;</span><br><span class="line">        _MyQueue = [[NSOperationQueue alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _MyQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">    //将操作添加到队列 - 会自动异步执行调度方法</span><br><span class="line">    [self.MyQueue addOperationWithBlock:^&#123;</span><br><span class="line">        [NSThread currentThread].name = [@(i) stringValue];</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简洁很爽</p>
<h3 id="NSOperation线程间的通信"><a href="#NSOperation线程间的通信" class="headerlink" title="NSOperation线程间的通信"></a>NSOperation线程间的通信</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//小清新</span><br><span class="line">[self.MyQueue addOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;耗时操作&quot;);</span><br><span class="line">    [[NSOperationQueue mainQueue]addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;更新UI&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="NSOperation最大并发数"><a href="#NSOperation最大并发数" class="headerlink" title="NSOperation最大并发数"></a>NSOperation最大并发数</h3><ul>
<li>从 iOS 8.0 开始,无论使用 GCD还是 NSOperation ,都会开启很多线程</li>
<li>在 iOS 7.0 以前,GCD 通常只会开启 5  6条线程!</li>
<li>目前线程多了说明:<ol>
<li>底层的现场池更大了,能够拿到的线程资源多了!</li>
<li>多控制同时并发的现场数,要求就更高了!</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//添加操作进队列</span><br><span class="line">/*</span><br><span class="line"> 从 iOS 8.0 开始,无论使用 GCD还是 NSOperation ,都会开启很多线程</span><br><span class="line"> 在 iOS 7.0 以前,GCD 通常只会开启 5  6条线程!</span><br><span class="line"> 目前线程多了说明:</span><br><span class="line"> 1.底层的现场池更大了,能够拿到的线程资源多了!</span><br><span class="line"> 2.多控制同时并发的现场数,要求就更高了!</span><br><span class="line"> */</span><br><span class="line">    </span><br><span class="line">for (int i = 0;i &lt; 20; i++) &#123;</span><br><span class="line">    [self.MyQueue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@---%d&quot;,[NSThread currentThread],i);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;NSThread: 0x600003e984c0&gt;&#123;number = 4, name = (null)&#125;---1</span><br><span class="line">&lt;NSThread: 0x600003e98540&gt;&#123;number = 5, name = (null)&#125;---2</span><br><span class="line">&lt;NSThread: 0x600003e96980&gt;&#123;number = 6, name = (null)&#125;---3</span><br><span class="line">&lt;NSThread: 0x600003e9c6c0&gt;&#123;number = 3, name = (null)&#125;---0</span><br><span class="line">&lt;NSThread: 0x600003e984c0&gt;&#123;number = 4, name = (null)&#125;---4</span><br><span class="line">&lt;NSThread: 0x600003e96980&gt;&#123;number = 6, name = (null)&#125;---5</span><br><span class="line">&lt;NSThread: 0x600003e98540&gt;&#123;number = 5, name = (null)&#125;---6</span><br><span class="line">&lt;NSThread: 0x600003e9c6c0&gt;&#123;number = 3, name = (null)&#125;---7</span><br><span class="line">&lt;NSThread: 0x600003e984c0&gt;&#123;number = 4, name = (null)&#125;---8</span><br><span class="line">&lt;NSThread: 0x600003e96980&gt;&#123;number = 6, name = (null)&#125;---9</span><br><span class="line">&lt;NSThread: 0x600003e98540&gt;&#123;number = 5, name = (null)&#125;---10</span><br><span class="line">&lt;NSThread: 0x600003e9e280&gt;&#123;number = 7, name = (null)&#125;---11</span><br><span class="line">&lt;NSThread: 0x600003e8f080&gt;&#123;number = 8, name = (null)&#125;---12</span><br><span class="line">&lt;NSThread: 0x600003e8f280&gt;&#123;number = 9, name = (null)&#125;---13</span><br><span class="line">&lt;NSThread: 0x600003e9c6c0&gt;&#123;number = 3, name = (null)&#125;---14</span><br><span class="line">&lt;NSThread: 0x600003e984c0&gt;&#123;number = 4, name = (null)&#125;---15</span><br><span class="line">&lt;NSThread: 0x600003e98540&gt;&#123;number = 5, name = (null)&#125;---16</span><br><span class="line">&lt;NSThread: 0x600003e9e700&gt;&#123;number = 10, name = (null)&#125;---17</span><br><span class="line">&lt;NSThread: 0x600003e9e740&gt;&#123;number = 11, name = (null)&#125;---18</span><br><span class="line">&lt;NSThread: 0x600003e96980&gt;&#123;number = 6, name = (null)&#125;---19</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通常设置同时最大的并发操作数量</p>
<ul>
<li>WIFI: 5 至 6</li>
<li><p>流量 : 2 到 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.MyQueue.maxConcurrentOperationCount = 2;</span><br><span class="line"></span><br><span class="line">for (int i = 0;i &lt; 20; i++) &#123;</span><br><span class="line">    [self.MyQueue addOperationWithBlock:^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:1.0];</span><br><span class="line">        NSLog(@&quot;%@---%d&quot;,[NSThread currentThread],i);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;NSThread: 0x6000002d4f40&gt;&#123;number = 4, name = (null)&#125;---0</span><br><span class="line">&lt;NSThread: 0x6000002ad700&gt;&#123;number = 3, name = (null)&#125;---1</span><br><span class="line">&lt;NSThread: 0x6000002d9ec0&gt;&#123;number = 6, name = (null)&#125;---2</span><br><span class="line">&lt;NSThread: 0x6000002d5000&gt;&#123;number = 5, name = (null)&#125;---3</span><br><span class="line">&lt;NSThread: 0x6000002d5000&gt;&#123;number = 5, name = (null)&#125;---5</span><br><span class="line">&lt;NSThread: 0x6000002ad700&gt;&#123;number = 3, name = (null)&#125;---4</span><br><span class="line">&lt;NSThread: 0x6000002ad700&gt;&#123;number = 3, name = (null)&#125;---7</span><br><span class="line">&lt;NSThread: 0x6000002d9ec0&gt;&#123;number = 6, name = (null)&#125;---6</span><br><span class="line">&lt;NSThread: 0x6000002d9ec0&gt;&#123;number = 6, name = (null)&#125;---9</span><br><span class="line">&lt;NSThread: 0x6000002d4f40&gt;&#123;number = 4, name = (null)&#125;---8</span><br><span class="line">&lt;NSThread: 0x6000002d9ec0&gt;&#123;number = 6, name = (null)&#125;---10</span><br><span class="line">&lt;NSThread: 0x6000002d4f40&gt;&#123;number = 4, name = (null)&#125;---11</span><br><span class="line">&lt;NSThread: 0x6000002d9ec0&gt;&#123;number = 6, name = (null)&#125;---13</span><br><span class="line">&lt;NSThread: 0x6000002ad700&gt;&#123;number = 3, name = (null)&#125;---12</span><br><span class="line">&lt;NSThread: 0x6000002ad700&gt;&#123;number = 3, name = (null)&#125;---15</span><br><span class="line">&lt;NSThread: 0x6000002d4f40&gt;&#123;number = 4, name = (null)&#125;---14</span><br><span class="line">&lt;NSThread: 0x6000002d5000&gt;&#123;number = 5, name = (null)&#125;---16</span><br><span class="line">&lt;NSThread: 0x6000002ad700&gt;&#123;number = 3, name = (null)&#125;---17</span><br><span class="line">&lt;NSThread: 0x6000002ad700&gt;&#123;number = 3, name = (null)&#125;---19</span><br><span class="line">&lt;NSThread: 0x6000002d4f40&gt;&#123;number = 4, name = (null)&#125;---18</span><br><span class="line">```  </span><br><span class="line">为什么实际当中打印会多出几个线程？</span><br><span class="line">1. 线程中的任务完成以后会回收线程</span><br><span class="line">2. 当一个任务完成需要从队列中取新的任务，取一个空间的线程，或者是开辟新线程的时候，而1中的线程正在回收，所以这个任务开辟的线程会比原先的线程number+1</span><br><span class="line"></span><br><span class="line">## `NSOperationQueue`的属性和方法</span><br><span class="line"></span><br><span class="line">### suspended</span><br><span class="line"></span><br><span class="line">- `NSOperationQueue`的一个属性，可以控制`NSOperationQueue`队列的挂起还是继续</span><br><span class="line">	- isSuspended 判断是否是挂起</span><br><span class="line">	- suspended   修改`NSOperationQueue`挂起或者继续</span><br></pre></td></tr></table></figure>
<pre><code>//队列是否挂起
if(self.MyQueue.isSuspended){

    NSLog(@&quot;继续&quot;);
    self.MyQueue.suspended = NO;

}else{
    NSLog(@&quot;暂停&quot;);
    self.MyQueue.suspended = YES;
}

-(void)demo1{
    self.MyQueue.maxConcurrentOperationCount = 2;

    for (int i = 0;i &lt; 20; i++) {
        [self.MyQueue addOperationWithBlock:^{
            [NSThread sleepForTimeInterval:1.0];
            NSLog(@&quot;%@---%d&quot;,[NSThread currentThread],i);
        }];
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### operationCount</span><br><span class="line"></span><br><span class="line">可以拿到队列中的操作数</span><br></pre></td></tr></table></figure>
</code></pre><p>NSLog(@”%tu”,self.MyQueue.operationCount);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 取消`NSOperationQueue`中的所有操作</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. 队列挂起的时候，取消队列所有操作，不会清空队列的`operationCoount`只有在队列继续的时候才能清空</span><br><span class="line">2. 正在执行的操作也不会被清空，也不会被取消</span><br></pre></td></tr></table></figure></p>
<p>[self.MyQueue cancelAllOperations];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `NSOperation`依赖关系(Dependency)</span><br><span class="line"></span><br><span class="line">waitUntilFinished中的YES会卡住当前线程</span><br></pre></td></tr></table></figure>
<p>[self.MyQueue addOperations:@[op1,op2,op3] waitUntilFinished:YES];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperation依赖关系：</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)addDependency:(NSOperation *)op;</li>
<li>(void)removeDependency:(NSOperation *)op;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例子：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/*</p>
<ul>
<li>例子：下载/解压/通知用户<br>**/</li>
</ul>
<p>NSBlockOperation <em>op1 = [NSBlockOperation blockOperationWithBlock:^{<br>    NSLog(@”下载----%@”,[NSThread currentThread]);<br>}];<br>NSBlockOperation </em>op2 = [NSBlockOperation blockOperationWithBlock:^{<br>    NSLog(@”解压----%@”,[NSThread currentThread]);<br>}];<br>NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{<br>    NSLog(@”通知用户----%@”,[NSThread currentThread]);<br>}];</p>
<p>//NSOperation 提供了依赖关系<br>//注意：不要指定循环依赖，队列就不工作了，不会造成死锁。<br>[op2 addDependency:op1];<br>[op3 addDependency:op2];</p>
<p>//YES 会卡住当前线程<br>[self.MyQueue addOperations:@[op1,op2,op3] waitUntilFinished:YES];<br>NSLog(@”come here  %@”,[NSThread currentThread]);</p>
<pre><code>//主线程通知用户
</code></pre><p>[[NSOperationQueue mainQueue]addOperation:op3];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">打印结果：</span><br></pre></td></tr></table></figure>
<p>下载—-&lt;NSThread: 0x600002dc3240&gt;{number = 3, name = (null)}<br>解压—-&lt;NSThread: 0x600002dc5440&gt;{number = 4, name = (null)}<br>通知用户—-&lt;NSThread: 0x600002dc3240&gt;{number = 3, name = (null)}<br>come here  &lt;NSThread: 0x600002d9cb00&gt;{number = 1, name = main}<br><code>`</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>只要是<code>NSOperation</code>的子类，就可以添加到<code>NSOperationQueue</code>。</li>
<li>如果使用<code>NSOperation</code>可以使代码更加简洁，代码会更加工整，<code>NSOperation</code>能办到的事情，<code>GCD</code>也都可以办到。</li>
<li><code>NSOperation</code>相比<code>GCD</code>节约来代码行数，并且是面向对象的。</li>
<li><code>NSOperation</code>是苹果大力推荐的<code>并发</code>技术。</li>
<li>NSOperation是一个抽象类<ul>
<li>特点：不能直接使用</li>
<li>目的：定义子类共有的属性和方法</li>
<li>子类：NSInvocationOperation、NSBlockOperation</li>
</ul>
</li>
</ul>
<h2 id="GCD-和-NSOperation-对比"><a href="#GCD-和-NSOperation-对比" class="headerlink" title="GCD 和 NSOperation 对比"></a>GCD 和 NSOperation 对比</h2><p>GCD 在 iOS 4.0 推出,主要针对多核处理器做了优化的并发技术,是C语言的</p>
<ul>
<li>将”任务”[block]添加到 队列[串行/并发/主队列/全局队列] ,并且指定执行任务的函数[同步/异步]</li>
<li>线程间的通讯  dispatch_get_main_queue()</li>
<li>提供了一些 NSOperation 不具备的功能<ul>
<li>一次执行</li>
<li>延迟执行</li>
<li>调度组(在op中也可以做到,有点麻烦)</li>
<li>信号量</li>
<li>apply(重复)</li>
</ul>
</li>
</ul>
<p>NSOperation 在 iOS 2.0 推出的,苹果推出 GCD以后,对NSOperation 底层做了重写!</p>
<ul>
<li>将操作[异步执行的任务] 添加到队列[并发队列],就会立刻异步执行</li>
<li>mainQueue</li>
<li>提供了一些GCD 实现起来比较困难的功能</li>
<li>最大并发线程</li>
<li>队列的暂停/继续</li>
<li>取消所有操作</li>
<li>指定操作之间的依赖关系(GCD 用同步来实现)</li>
</ul>
<h1 id="多线程NSOperation结构图"><a href="#多线程NSOperation结构图" class="headerlink" title="多线程NSOperation结构图"></a>多线程NSOperation结构图</h1><p><img src="https://upload-images.jianshu.io/upload_images/7980283-71fcf80e53a8cdeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSOperation.png"></p>

      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/07/02/深入浅出iOS多线程(四)——NSOperation多线程/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
    
<article id="post-深入浅出iOS多线程(三)——GCD多线程" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/02/深入浅出iOS多线程(三)——GCD多线程/">深入浅出iOS多线程(三)——GCD多线程</a>
    </h1>
  

        
        <a href="/2019/07/02/深入浅出iOS多线程(三)——GCD多线程/" class="archive-article-date">
  	<time datetime="2019-07-02T04:10:56.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-07-02</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="GCD简介"><a href="#GCD简介" class="headerlink" title="GCD简介"></a>GCD简介</h1><p>前面分析的pthread和NSThread多线程技术，直接操作线程，而下面分析的GCD以及下一篇NSOpration都是并发解决技术</p>
<h2 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h2><ul>
<li>全称是Grand Central Dispatch，可译为“宏大的中央调度”</li>
<li>纯C语言，提供了非常强大的函数</li>
<li>GCD完全面向过程的并发解决技术</li>
</ul>
<h2 id="GCD的优势"><a href="#GCD的优势" class="headerlink" title="GCD的优势"></a>GCD的优势</h2><ul>
<li>GCD是苹果公司为多核的并行运算提出的解决方案</li>
<li>GCD会自动利用更多的CPU内核(比如双核、四核)</li>
<li>GCD会自动管理多线程的生命周期(创建线程、调度任务、销毁线程)</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li>
</ul>
<h2 id="GCD的两个核心概念"><a href="#GCD的两个核心概念" class="headerlink" title="GCD的两个核心概念"></a>GCD的两个核心概念</h2><ul>
<li>任务：执行什么操作</li>
<li>队列：用来存放任务</li>
</ul>
<h2 id="GCD的使用步骤"><a href="#GCD的使用步骤" class="headerlink" title="GCD的使用步骤"></a>GCD的使用步骤</h2><ul>
<li>确定任务</li>
<li>将任务添加到队列中<ul>
<li>GCD会自动将队列的任务取出，放到对应的线程中执行</li>
<li>任务的取出遵循队列的FIFO原则，先进先出，后进后出</li>
<li>程序员要做的，只是将任务添加到队列，队列按照程序员指定的方式，调度任务执行任务的方法：同步和异步<ul>
<li>同步：一个任务没有结束，就不会执行下一个任务</li>
<li>异步：不用等待任务执行完毕，就会执行下一个任务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="GCD简单使用"><a href="#GCD简单使用" class="headerlink" title="GCD简单使用"></a>GCD简单使用</h2><h3 id="同步GCD"><a href="#同步GCD" class="headerlink" title="同步GCD"></a>同步GCD</h3><ul>
<li><p>同步执行方法，当前任务不执行完成，就不会执行下一个任务，同步执行不会开启线程</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1.创建队列</span><br><span class="line">dispatch_queue_t g = dispatch_get_global_queue(0, 0);</span><br><span class="line">//2.将任务添加到队列中</span><br><span class="line">//2.1.定义任务</span><br><span class="line">void(^task)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;;</span><br><span class="line">//2.2 添加任务到队列，并且直接执行</span><br><span class="line">dispatch_sync(g, task);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="异步GCD"><a href="#异步GCD" class="headerlink" title="异步GCD"></a>异步GCD</h3><ul>
<li><p>异步执行方法，如果任务没有执行完毕，可以不用等待，异步执行下一个任务，具备开启线程的能力，异步通常又是多线程的代名词</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1.创建队列</span><br><span class="line">  dispatch_queue_t g = dispatch_get_global_queue(0, 0);</span><br><span class="line">  //2.将任务添加到队列中</span><br><span class="line">  //2.1.定义任务</span><br><span class="line">  void(^task)(void) = ^&#123;</span><br><span class="line">      NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">  &#125;;</span><br><span class="line">  //2.2 添加任务到队列，并且直接执行</span><br><span class="line">  dispatch_async(g, task);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GCD的线程通信-GCD主线程"><a href="#GCD的线程通信-GCD主线程" class="headerlink" title="GCD的线程通信(GCD主线程)"></a>GCD的线程通信(GCD主线程)</h3><ul>
<li>主队列，更新UI,专门负责在主线程上调度任务的队列</li>
<li>主线程中用同步跟异步都是一样的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0   ), ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="GCD子线程下载图片，主线程更新UI"><a href="#GCD子线程下载图片，主线程更新UI" class="headerlink" title="GCD子线程下载图片，主线程更新UI"></a>GCD子线程下载图片，主线程更新UI</h3><ul>
<li>用GCD来异步下载图片，主线程中更新UI<ul>
<li>简单逻辑来讲，用GCD更加简洁，看着就想一气呵成很爽</li>
<li>开发是要看线程的通信(线程中的业务逻辑是否过于复杂)，如果过于复杂，建议使用@selector()的形式去使用。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSURL * url = [NSURL URLWithString:@&quot;https://images.unsplash.com/photo-1496840220025-4cbde0b9df65?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2734&amp;q=80&quot;];</span><br><span class="line">    NSData * data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        self.imageView.image = image;</span><br><span class="line">        [self.imageView sizeToFit];</span><br><span class="line">        self.scrollView.contentSize = image.size;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="GCD队列"><a href="#GCD队列" class="headerlink" title="GCD队列"></a>GCD队列</h2><p>先把GCD异步、同步和队列、block的概念梳理一遍：</p>
<ul>
<li><strong>GCD 核心概念：将任务添加到队列，指定任务执行的方法</strong><ul>
<li>任务<pre><code>- 使用block封装
</code></pre><ul>
<li>block就是一个提前准备的代码块，在需要的时候执行<ul>
<li>队列(负责调度任务)</li>
</ul>
</li>
<li>串行队列：一个接一个的调度任务<ul>
<li>并发队列：可以同时调度多个任务<ul>
<li>任务执行函数(任务都需要在线程中执行)</li>
</ul>
</li>
</ul>
</li>
<li>同步执行：当前指令不完成，不会执行下个指令</li>
<li>异步执行：当前指令不完成，不会等待，同样执行下个指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="GCD串行队列"><a href="#GCD串行队列" class="headerlink" title="GCD串行队列"></a>GCD串行队列</h3><ul>
<li>串行队列，同步任务<ul>
<li>不会开启线程，顺序执行</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)gcdQueueDemo1&#123;</span><br><span class="line">    </span><br><span class="line">    //队列：串行</span><br><span class="line">    /**</span><br><span class="line">     1.队列名称</span><br><span class="line">     2.队列的属性 ：DISPATCH_QUEUE_SERIAL  标示串行</span><br><span class="line">     **/</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t q = dispatch_queue_create(&quot;struggle3g&quot;, NULL);</span><br><span class="line">    //2.同步执行任务</span><br><span class="line">    for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">        dispatch_sync(q, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@,%d&quot;,[NSThread currentThread],i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>串行队列，异步任务<ul>
<li>不会开启线程，顺序执行</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)gcdQueueDemo2&#123;</span><br><span class="line">    </span><br><span class="line">    //队列：串行</span><br><span class="line">    /**</span><br><span class="line">     1.队列名称</span><br><span class="line">     2.队列的属性 ：DISPATCH_QUEUE_SERIAL  标示串行</span><br><span class="line">     **/</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t q = dispatch_queue_create(&quot;struggle3g&quot;, NULL);</span><br><span class="line">    //2.异步执行任务</span><br><span class="line">    for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">        dispatch_sync(q, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@,%d&quot;,[NSThread currentThread],i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>总结：<ul>
<li>会不会去线程池中拿线程是由任务类型来决定(异步or同步)</li>
<li>串行队列：肯定是先进先出，<ul>
<li>当一个任务在执行的时候，下一个任务是没有执行的可能的</li>
</ul>
</li>
<li>在串行队列中，每次只能执行一个任务，而不管你任务是异步还是同步，队列已经把下一个任务给封住了，只有串行队列中的任务完成了，才能执行下一个任务。</li>
</ul>
</li>
</ul>
<h3 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h3><ul>
<li><p>并发队列，异步任务</p>
<ul>
<li><p>会开线程，不会顺序执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)gcdQueueDemo3&#123;</span><br><span class="line">    </span><br><span class="line">    //队列：并发</span><br><span class="line">    /**</span><br><span class="line">     1.队列名称</span><br><span class="line">     2.队列的属性 ：DISPATCH_QUEUE_CONCURRENT  并发串行</span><br><span class="line">     **/</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t q = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    //2.异步执行任务</span><br><span class="line">    for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">        dispatch_async(q, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@,%d&quot;,[NSThread currentThread],i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>并发队列，同步任务</p>
<ul>
<li><p>不会开线程，按顺序执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)gcdQueueDemo4&#123;</span><br><span class="line">    </span><br><span class="line">    //队列：并发</span><br><span class="line">    /**</span><br><span class="line">     1.队列名称</span><br><span class="line">     2.队列的属性 ：DISPATCH_QUEUE_CONCURRENT  并发串行</span><br><span class="line">     **/</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t q = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    //2.异步执行任务</span><br><span class="line">    for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">        dispatch_sync(q, ^&#123;</span><br><span class="line">            NSLog(@&quot;%@,%d&quot;,[NSThread currentThread],i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="全局队列"><a href="#全局队列" class="headerlink" title="全局队列"></a>全局队列</h3><p>全剧队列创建API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_global_t </span><br><span class="line">dispatch_get_global_queue(long identifier, unsigned long flags);</span><br></pre></td></tr></table></figure>
<p>参数介绍：涉及到系统适配</p>
<ul>
<li><p>iOS 8   服务质量</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QOS_CLASS_USER_INTERACTIVE    用户交互(希望线程快速被执行,不要用好使的操作)</span><br><span class="line">QOS_CLASS_USER_INITIATED      用户需要的(同样不要使用耗时操作)</span><br><span class="line">QOS_CLASS_DEFAULT             默认的(给系统来重置队列的)</span><br><span class="line">QOS_CLASS_UTILITY             使用工具(用来做耗时操作)</span><br><span class="line">QOS_CLASS_BACKGROUND          后台</span><br><span class="line">QOS_CLASS_UNSPECIFIED         没有指定优先级</span><br></pre></td></tr></table></figure>
</li>
<li><p>iOS 7  调度的优先级</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- DISPATCH_QUEUE_PRIORITY_HIGH 2               高优先级</span><br><span class="line">- DISPATCH_QUEUE_PRIORITY_DEFAULT 0            默认优先级</span><br><span class="line">- DISPATCH_QUEUE_PRIORITY_LOW (-2)             低优先级</span><br><span class="line">- DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN 后台优先级</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>提示:尽可能不要选择BACKGROUND 优先级,服务质量,线程执行会很慢</p>
<ul>
<li>第一个参数：identifier：iOS8给服务质量，iOS7是优先级<br>第二个参数：flags：为未来使用的一个保留值，现在始终给0</li>
</ul>
<h3 id="队列总结"><a href="#队列总结" class="headerlink" title="队列总结"></a>队列总结</h3><ul>
<li>开不开线程，取决于执行任务的函数，同步不开，异步才能开</li>
<li>开几条线程，取决于队列，串行开一条，并发可以开多条(异步)</li>
<li><p>全局队列 &amp; 并发队列</p>
<ul>
<li>1&gt; 名称,并发队列取名字,适合于企业开发跟踪错误<ul>
<li>2&gt; release,在MRC 并发队列 需要使用的</li>
<li>dispatch_release(q);//ARC 情况下不需要release !</li>
</ul>
</li>
</ul>
</li>
<li><p>全局队列 &amp; 串行队列</p>
<ul>
<li>全局队列: 并发,能够调度多个线程,执行效率高</li>
<li>费电 性能提高<br>串行队列:一个一个执行,执行效率低<ul>
<li>省电 性能低</li>
</ul>
</li>
</ul>
</li>
<li><p>判断依据:用户上网方式</p>
<ul>
<li>WIFI : 可以多开线程</li>
<li>流量  : 尽量少开线程</li>
</ul>
</li>
</ul>
<h2 id="GCD队列实际应用"><a href="#GCD队列实际应用" class="headerlink" title="GCD队列实际应用"></a>GCD队列实际应用</h2><ul>
<li>在开发中，通常将耗时操作放入后台执行，有时候，有些任务彼此有依赖关系</li>
<li><p>例子：购买-&gt;登陆-&gt;支付,3种方式，代码如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//一. 并发队列 同步任务</span><br><span class="line">dispatch_queue_t buyqueue = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">//1. 用户购买</span><br><span class="line">dispatch_sync(buyqueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;用户购买&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//2. 用户登陆</span><br><span class="line">dispatch_sync(buyqueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;用户登陆&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//3. 用户支付</span><br><span class="line">dispatch_sync(buyqueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;用户支付&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//二. 串行队列 异步任务</span><br><span class="line">dispatch_queue_t buyqueue = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">//1. 用户购买</span><br><span class="line">dispatch_async(buyqueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;用户购买&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//2. 用户登陆</span><br><span class="line">dispatch_async(buyqueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;用户登陆&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//3. 用户支付</span><br><span class="line">dispatch_async(buyqueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;用户支付&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//三. 串行队列 同步任务</span><br><span class="line">dispatch_queue_t buyqueue = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">//1. 用户购买</span><br><span class="line">dispatch_sync(buyqueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;用户购买&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//2. 用户登陆</span><br><span class="line">dispatch_sync(buyqueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;用户登陆&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//3. 用户支付</span><br><span class="line">dispatch_sync(buyqueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;用户支付&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>例子：并发队列调度多个任务前,指定一个同步任务,让所有的异步任务,等待同步任务执行完成,这就是依赖关系</p>
<ul>
<li><p>同步任务,会造成一个死锁!</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t q = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">//任务</span><br><span class="line">void (^task)()=^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        NSLog(@&quot;%d   %@&quot;,i ,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    //1.用户登录</span><br><span class="line">    dispatch_sync(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;用户登录  %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    //2.支付</span><br><span class="line">    dispatch_async(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;支付  %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    //3.下载</span><br><span class="line">    dispatch_async(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;下载  %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line">dispatch_async(q, task);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="GCD延迟执行-GCD定时器"><a href="#GCD延迟执行-GCD定时器" class="headerlink" title="GCD延迟执行(GCD定时器)"></a>GCD延迟执行(GCD定时器)</h2><ul>
<li>从现在开始,过了多少纳秒之后,让 queue队列,调度 block 任务,异步执行!</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> </span><br><span class="line"> 参数:</span><br><span class="line"> 1.dispatch_time_t</span><br><span class="line"> 2.queue</span><br><span class="line"> 3.block</span><br><span class="line"> */</span><br><span class="line">dispatch_time_t when = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.00003 * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(when, dispatch_queue_create(&quot;struggle3g&quot;, NULL), ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="GCD一次执行"><a href="#GCD一次执行" class="headerlink" title="GCD一次执行"></a>GCD一次执行</h2><ul>
<li>苹果提供的 一次执行机制,不仅能够保证一次执行!而且是线程安全的!!<ul>
<li>更多的时候是用这种机制来做一个单例</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//苹果提供的 一次执行机制,不仅能够保证一次执行!而且是线程安全的!!</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">NSLog(@&quot;%ld&quot;,onceToken);</span><br><span class="line">//苹果推荐使用 gcd 一次执行,效率高</span><br><span class="line">//不要使用互斥锁,效率低!</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    //只会执行一次!!</span><br><span class="line">    NSLog(@&quot;执行了%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="GCD调度组-Group"><a href="#GCD调度组-Group" class="headerlink" title="GCD调度组(Group)"></a>GCD调度组(Group)</h2><ul>
<li>创建队列</li>
<li>创建调度组</li>
<li>添加任务，让队列调度</li>
<li>所有线程任务执行完毕，通知</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//1.队列</span><br><span class="line">dispatch_queue_t  q = dispatch_get_global_queue(0, 0);</span><br><span class="line">//2.调用组</span><br><span class="line">dispatch_group_t  g = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">//3.添加任务，让队列调度，任务执行情况，最后通知群组</span><br><span class="line">dispatch_group_async(g, q, ^&#123;</span><br><span class="line">    NSLog(@&quot;downloadA %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(g, q, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:5];</span><br><span class="line">    NSLog(@&quot;downloadB %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(g, q, ^&#123;</span><br><span class="line">    NSLog(@&quot;downloadC %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">//4.所有任务执行完毕，通知</span><br><span class="line">//dispatch_group_notify 本身也是异步的</span><br><span class="line">dispatch_group_notify(g, q, ^&#123;</span><br><span class="line">    NSLog(@&quot;OK %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">//如果想要dispatch_group_notify直接在主线程需要在其中传入主线程队列</span><br><span class="line">dispatch_group_notify(g, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;OK %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="GCD主队列"><a href="#GCD主队列" class="headerlink" title="GCD主队列"></a>GCD主队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mainqueue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<ul>
<li>主队列 &amp; 串行队列的区别</li>
<li>都是 一个一个安排任务</li>
<li><p>队列特点:FIFO</p>
</li>
<li><p>并发队列  可以调度很多任务</p>
</li>
<li>串行独立, 必须等待一个任务执行完成,再调度另外一个<ul>
<li>最多只能开启一条线程</li>
</ul>
</li>
<li>主队列,以FIFO调度任务,如果主线程上有任务在执行,主队列就不会调度任务<ul>
<li>主要是负责在主线程上执行任务</li>
</ul>
</li>
</ul>
<h3 id="主队列同步任务"><a href="#主队列同步任务" class="headerlink" title="主队列同步任务"></a>主队列同步任务</h3><ul>
<li><p>崩溃</p>
<ul>
<li><p>主队列无法实现同步任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;这里!!%@&quot;,[NSThread currentThread]);</span><br><span class="line">//1.队列 --&gt; 已启动主线程,就可以获取主队列</span><br><span class="line">dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">//2.同步任务</span><br><span class="line">dispatch_sync(q, ^&#123;</span><br><span class="line">    NSLog(@&quot;我要崩溃 %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;come here&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="主线程异步任务"><a href="#主线程异步任务" class="headerlink" title="主线程异步任务"></a>主线程异步任务</h3><ul>
<li>主队列是专门负责在主线程上调度任务的队列 –&gt; 不会开线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//1.队列 --&gt; 已启动主线程,就可以获取主队列</span><br><span class="line">dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">//2.异步任务</span><br><span class="line">dispatch_async(q, ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;come here&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="主线程同步任务-不死锁"><a href="#主线程同步任务-不死锁" class="headerlink" title="主线程同步任务(不死锁)"></a>主线程同步任务(不死锁)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void (^task)(void) = ^&#123;</span><br><span class="line">    NSLog(@&quot;这里!!%@&quot;,[NSThread currentThread]);</span><br><span class="line">    //1.队列 --&gt; 已启动主线程,就可以获取主队列</span><br><span class="line">    dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    //2.同步任务</span><br><span class="line">    dispatch_sync(q, ^&#123;</span><br><span class="line">        NSLog(@&quot;主线程 %@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;come here&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">//开启一个线程</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), task);</span><br></pre></td></tr></table></figure>
<h2 id="GCD-Apply-重复调用"><a href="#GCD-Apply-重复调用" class="headerlink" title="GCD(Apply)重复调用"></a>GCD(Apply)重复调用</h2><ul>
<li>重复执行某个任务，但是注意这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）。</li>
</ul>
<h3 id="全局并发队列中的Apply"><a href="#全局并发队列中的Apply" class="headerlink" title="全局并发队列中的Apply"></a>全局并发队列中的Apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">全局并发队列</span><br><span class="line">结果验证：并发队列,开启子线程，乱序执行</span><br><span class="line">*/</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">dispatch_apply(10, queue, ^(size_t count) &#123;</span><br><span class="line">    NSLog(@&quot;count = %zu,%@&quot;,count, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 并发队列</span><br><span class="line"> 结果验证：并发队列，开启子线程，乱序执行</span><br><span class="line"> */</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_apply(10, queue, ^(size_t count) &#123;</span><br><span class="line">    NSLog(@&quot;count = %zu,%@&quot;,count, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 串行队列</span><br><span class="line"> 结果验证：串行队列，按顺序执行</span><br><span class="line"> */</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_apply(10, queue, ^(size_t count) &#123;</span><br><span class="line">    NSLog(@&quot;count = %zu,%@&quot;,count, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="注意主线程队列中的Apply"><a href="#注意主线程队列中的Apply" class="headerlink" title="注意主线程队列中的Apply"></a>注意主线程队列中的Apply</h3><ul>
<li><p>主线程中的Apply直接崩溃，在堆栈中我们可以看到的信息</p>
<ul>
<li><code>__DISPATCH_WAIT_FOR_QUEUE__</code></li>
<li>调度等待队列</li>
<li><p>线程死锁，由于在主线程开启了一个同步任务，而主线程运行到<code>dispatch_sync</code>的时候，dispatch_sync中的内容需要让主线程其他任务等待它完成时才能运行，而主线程其他任务也是需要<code>dispatch_sync</code>等待它们执行完成时才能调用，从而造成线程的死锁问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//主线程队列 同步任务</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="GCD-dispatch-barrier-async"><a href="#GCD-dispatch-barrier-async" class="headerlink" title="GCD(dispatch_barrier_async())"></a>GCD(dispatch_barrier_async())</h2><ul>
<li>使用此方法创建的任务首先会查看队列中有没有别的任务要执行，如果有，则会等待已有任务执行完毕再执行；</li>
<li>同时在此方法后添加的任务必须等待此方法中任务执行后才能执行。</li>
<li>利用这个方法可以控制执行顺序，例如前面先加载最后一张图片的需求就可以先使用这个方法将最后一张图片加载的操作添加到队列，然后调用dispatch_async()添加其他图片加载任务</li>
</ul>
<p>dispatch_barrier_async顾名思义就是栅栏函数，就是等于在一个并发队列中，在多个任务之间增加一道栅栏，当栅栏以及栅栏之前的任务完成以后还能执行，栅栏以后的代码。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  </span><br><span class="line">  dispatch_async(queue, ^&#123;</span><br><span class="line">      NSLog(@&quot;++1++%@&quot;,[NSThread currentThread]);</span><br><span class="line">  &#125;);</span><br><span class="line">  dispatch_async(queue, ^&#123;</span><br><span class="line">      NSLog(@&quot;++2++%@&quot;,[NSThread currentThread]);</span><br><span class="line">  &#125;);</span><br><span class="line">  dispatch_async(queue, ^&#123;</span><br><span class="line">      NSLog(@&quot;++3++%@&quot;,[NSThread currentThread]);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">  	</span><br><span class="line">      NSLog(@&quot;栅栏函数&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  dispatch_async(queue, ^&#123;</span><br><span class="line">      NSLog(@&quot;++4++%@&quot;,[NSThread currentThread]);</span><br><span class="line">  &#125;);</span><br><span class="line">  dispatch_async(queue, ^&#123;</span><br><span class="line">      NSLog(@&quot;++5++%@&quot;,[NSThread currentThread]);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
</code></pre><p>输出结果一定是 1、2、3前面三个部分顺序执行，第四个一定是栅栏函数，后面2个顺序打乱。</p>
<p><code>dispatch_barrier_async</code> 和<code>dispatch_barrier_sync</code>的区别就是阻不阻当前线程</p>
<h2 id="GCD信号量操作"><a href="#GCD信号量操作" class="headerlink" title="GCD信号量操作"></a>GCD信号量操作</h2><h3 id="信号量的API"><a href="#信号量的API" class="headerlink" title="信号量的API"></a>信号量的API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t dispatch_semaphore_create(long value);</span><br><span class="line">long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</span><br><span class="line">long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dispatch_semaphore_create</code>创建一个<code>dispatch_semaphore_t</code>的信号量，并且创建的时候需要指定信号量的大小，<code>dispatch_semaphore_wait</code>等待信号量，如果信号量的值为0，那么该函数就会一直等待，也就是不返回(相当于阻塞当前线程)，直到该函数<br>等待的信号量的值大于等于1，该函数会对信号量的值进行减1操作，然后返回<br><code>dispatch_semaphore_signal</code>发送信号量，该函数会对信号量的值进行+1操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_wait的第二个参数</span><br><span class="line">DISPATCH_TIME_NOW：超时时间为0，表示忽略信号量，直接运行</span><br><span class="line">DISPATCH_TIME_FOREVER：超时时间为永远，表示会一直等待信号量为正数，才会继续运行</span><br></pre></td></tr></table></figure>
<h3 id="并发队列，异步执行实现同步操作"><a href="#并发队列，异步执行实现同步操作" class="headerlink" title="并发队列，异步执行实现同步操作"></a>并发队列，异步执行实现同步操作</h3><p>首先建立一个并发队列，异步执行的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;++1++%@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;++2++%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;++3++%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++3++&lt;NSThread: 0x600003b7c840&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">++2++&lt;NSThread: 0x600003b6d640&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">++1++&lt;NSThread: 0x600003b77a80&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>从上述结果来看，队列中的任务并不是同步执行的，那么我们现在就可以使用信号量在进行同步操作,代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;struggle3g&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;++1++%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;++2++%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;++3++%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>打印结果如下：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++1++&lt;NSThread: 0x6000029e73c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++2++&lt;NSThread: 0x6000029ef280&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">++3++&lt;NSThread: 0x6000029ef280&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>让多个异步任务按照同步顺序执行，直接在同步队列异步操作不是更好吗？为什么要使用复杂的信号量，这是因为，同步队列中当中只是在一个线程当中运行，而信号量可以充分利用多线程，它会开启子线程。所以同步队列异步操作丧失了并发执行的可能性。虽然可以完成任务，但是却没有充分发挥CPU多线程的优势</p>
<h2 id="GCD结构图"><a href="#GCD结构图" class="headerlink" title="GCD结构图"></a>GCD结构图</h2><p><img src="https://upload-images.jianshu.io/upload_images/7980283-28702f9671e4ef50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GCD结构图.png"></p>

      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/07/02/深入浅出iOS多线程(三)——GCD多线程/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
    
<article id="post-iOS基础全面分析之三(KVO全面分析)" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/29/iOS基础全面分析之三(KVO全面分析)/">iOS基础全面分析之三(KVO全面分析)</a>
    </h1>
  

        
        <a href="/2019/06/29/iOS基础全面分析之三(KVO全面分析)/" class="archive-article-date">
  	<time datetime="2019-06-29T05:38:19.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-06-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="KVO全面分析"><a href="#KVO全面分析" class="headerlink" title="KVO全面分析"></a>KVO全面分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>KVO的全程是  Key-Value Observing，翻译过来就是键值监听，可以用于监听某个对象属性值的改变</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>相关的API在NSKeyValueObserving.h文件中都有声明</p>
<h3 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h3><p>主要是下面几种方法，这是KVO的基本组成部分</p>
<h4 id="基本使用API"><a href="#基本使用API" class="headerlink" title="基本使用API"></a>基本使用API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//基本使用</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;  //添加观察者</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0)); //删除观察者</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;  //删除观察者</span><br></pre></td></tr></table></figure>
<h4 id="观察者的回调"><a href="#观察者的回调" class="headerlink" title="观察者的回调"></a>观察者的回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//观察者的回调</span><br><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<h4 id="KVO属性依赖关系"><a href="#KVO属性依赖关系" class="headerlink" title="KVO属性依赖关系"></a>KVO属性依赖关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//观察者依赖关系  需要对象中重写</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));  //全部属性的依赖关系建立</span><br><span class="line">+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffecting&lt;#DependentKey#&gt; //单独属性的依赖关系建立</span><br></pre></td></tr></table></figure>
<h4 id="KVO属性观察自动通知"><a href="#KVO属性观察自动通知" class="headerlink" title="KVO属性观察自动通知"></a>KVO属性观察自动通知</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//KVO属性观察自动通知</span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key;//只有添加到观察者中的key才能调用这个方法，根据key的名称来确认这个key是否能够被观察  YES可以NO不可以</span><br><span class="line"></span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversOf&lt;key&gt;  //单个属性是否需要通知</span><br><span class="line"></span><br><span class="line">上述返回值为YES，设置好观察属性以及观察回调以后就会自动通知</span><br></pre></td></tr></table></figure>
<h4 id="KVO属性观察手动通知"><a href="#KVO属性观察手动通知" class="headerlink" title="KVO属性观察手动通知"></a>KVO属性观察手动通知</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//手动通知</span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key;//只有添加到观察者中的key才能调用这个方法，根据key的名称来确认这个key是否能够被观察  YES可以NO不可以</span><br><span class="line"></span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversOf&lt;key&gt;  //单个属性是否需要通知</span><br><span class="line"></span><br><span class="line">上述返回值为NO，设置好观察属性以及观察回调以后，属性修改并不会自动的去调用回调，而是需要在修改属性的前后加上两个方法。</span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key;</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
<h2 id="KVO的原理分析"><a href="#KVO的原理分析" class="headerlink" title="KVO的原理分析"></a>KVO的原理分析</h2><h3 id="isa指向问题"><a href="#isa指向问题" class="headerlink" title="isa指向问题"></a>isa指向问题</h3><p>在原理分析中我们需要知道isa指针的含义，先简单的回顾一下，isa指向的一个结构图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-2d02894c178d3582.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651" alt=""></p>
<ul>
<li>isa 指针指向<ul>
<li>类的实例对象的 isa 指向该类;该类的 isa 指向该类的 MetaClass</li>
<li>MetaCalss的isa对象指向RootMetaCalss</li>
<li>如果MetaClass是RootMetaCalss，那么该MetaClass的isa指针指向它自己</li>
</ul>
</li>
</ul>
<h3 id="创建KVO以后的isa指向"><a href="#创建KVO以后的isa指向" class="headerlink" title="创建KVO以后的isa指向"></a>创建KVO以后的isa指向</h3><h4 id="验证上述改变"><a href="#验证上述改变" class="headerlink" title="验证上述改变"></a>验证上述改变</h4><p>在类的实例对象设置观察者以后，类的isa指向发生了改变，如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-794f4c40f84f8f53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KVO原理之isa指向.png"></p>
<p>NSKVONotifying_<objectclass>这个对象如何得到的，观察者设置好以后，debug时在<code>Xcode`</code>lldb`我们可以得到这个对象，如下图：</objectclass></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-078a244d33c2f215.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="isa指向变更验证.png"></p>
<h4 id="什么时候生成的-NSKVONotifying-lt-ObjectClass"><a href="#什么时候生成的-NSKVONotifying-lt-ObjectClass" class="headerlink" title="什么时候生成的 NSKVONotifying_&lt;ObjectClass"></a>什么时候生成的 <code>NSKVONotifying_&lt;ObjectClass</code></h4><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">p = [Person3 new];</span><br><span class="line">    </span><br><span class="line">Class class = NSClassFromString(@&quot;NSKVONotifying_Person3&quot;);</span><br><span class="line">if(class)&#123;</span><br><span class="line">    NSLog(@&quot;NSKVONotifying_Person3 存在&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    NSLog(@&quot;NSKVONotifying_Person3 不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">[p addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:nil];</span><br><span class="line">    </span><br><span class="line">Class class1 = NSClassFromString(@&quot;NSKVONotifying_Person3&quot;);</span><br><span class="line">    </span><br><span class="line">if(class1)&#123;</span><br><span class="line">    NSLog(@&quot;NSKVONotifying_Person3 存在&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    NSLog(@&quot;NSKVONotifying_Person3 不存在&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码证明， <code>NSKVONotifying_&lt;ObjectClass</code>是在注册观察者以后生成的</p>
<h3 id="NSKVONotifying-lt-ObjectClass"><a href="#NSKVONotifying-lt-ObjectClass" class="headerlink" title="NSKVONotifying_&lt;ObjectClass"></a><code>NSKVONotifying_&lt;ObjectClass</code></h3><h4 id="NSKVONotifying-lt-ObjectClass当中都有什么方法"><a href="#NSKVONotifying-lt-ObjectClass当中都有什么方法" class="headerlink" title="NSKVONotifying_&lt;ObjectClass当中都有什么方法"></a><code>NSKVONotifying_&lt;ObjectClass</code>当中都有什么方法</h4><p>在注册了观察者以后我们查看，新添加的<code>NSKVONotifying_&lt;ObjectClass</code>中都有哪些方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[p addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:nil];</span><br><span class="line">Class class1 = NSClassFromString(@&quot;NSKVONotifying_Person3&quot;);</span><br><span class="line">[self printfMethod:class1];</span><br><span class="line"></span><br><span class="line">- (void)printfMethod:(Class)class&#123;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Method *methods = class_copyMethodList(class, &amp;count);</span><br><span class="line">    NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i&lt; count ; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        IMP im = method_getImplementation(method);</span><br><span class="line">        NSString * selstr = NSStringFromSelector(sel);</span><br><span class="line">        NSLog(@&quot;%@&quot;,selstr);</span><br><span class="line">        [array addObject:selstr];</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,array);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用lldb查看<code>NSKVONotifying_&lt;ObjectClass</code>中方法以及imp的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line">(lldb) po im</span><br><span class="line">(Foundation`_NSSetObjectValueAndNotify)</span><br><span class="line">2019-06-29 15:32:24.974049+0800 KVO的全面分析[4370:607232] setName:</span><br><span class="line">//2</span><br><span class="line">(lldb) po im</span><br><span class="line">(Foundation`NSKVOClass)</span><br><span class="line">2019-06-29 15:36:09.822166+0800 KVO的全面分析[4370:607232] class</span><br><span class="line">//3</span><br><span class="line">(lldb) po im</span><br><span class="line">(Foundation`NSKVODeallocate)</span><br><span class="line">2019-06-29 15:36:37.790595+0800 KVO的全面分析[4370:607232] dealloc</span><br><span class="line">//4</span><br><span class="line">(lldb) po im</span><br><span class="line">(Foundation`NSKVOIsAutonotifying)</span><br><span class="line">2019-06-29 15:36:56.961576+0800 KVO的全面分析[4370:607232] _isKVOA</span><br></pre></td></tr></table></figure></p>
<h4 id="NSKVONotifying-lt-ObjectClass的SuperClass验证"><a href="#NSKVONotifying-lt-ObjectClass的SuperClass验证" class="headerlink" title="NSKVONotifying_&lt;ObjectClass的SuperClass验证"></a><code>NSKVONotifying_&lt;ObjectClass</code>的SuperClass验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[self printClasses:[Person3 class]];</span><br><span class="line">/// 打印这个类常见的实例的所有父类</span><br><span class="line">- (void) printClasses:(Class) cls &#123;</span><br><span class="line">    </span><br><span class="line">    /// 注册类的总数</span><br><span class="line">    int count = objc_getClassList(NULL, 0);</span><br><span class="line">    </span><br><span class="line">    /// 创建一个数组， 其中包含给定对象</span><br><span class="line">    NSMutableArray* array = [NSMutableArray arrayWithObject:cls];</span><br><span class="line">    </span><br><span class="line">    /// 获取所有已注册的类</span><br><span class="line">    Class* classes = (Class*)malloc(sizeof(Class)*count);</span><br><span class="line">    objc_getClassList(classes, count);</span><br><span class="line">    </span><br><span class="line">    /// 遍历s</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        if (cls == class_getSuperclass(classes[i])) &#123;</span><br><span class="line">            [array addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(classes);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;classes = %@&quot;, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-06-29 15:50:23.740570+0800 KVO的全面分析[4607:663940] classes = (</span><br><span class="line">    Person3,</span><br><span class="line">    &quot;NSKVONotifying_Person3&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上述证明<code>NSKVONotifying_Person3</code> 是Person3的子类</p>
<h4 id="NSSetObjectValueAndNotify这个方法的实现逻辑"><a href="#NSSetObjectValueAndNotify这个方法的实现逻辑" class="headerlink" title="_NSSetObjectValueAndNotify这个方法的实现逻辑"></a><code>_NSSetObjectValueAndNotify</code>这个方法的实现逻辑</h4><p>在lldb中我们添加一个观察：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wetchpoint set variable self-&gt;p-&gt;_name</span><br></pre></td></tr></table></figure>
<p>从汇编当中我们可以看到这个方法大概使用了哪些逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">willChangeValueForKey</span><br><span class="line">[Person setName];</span><br><span class="line">didChangeValueForKey</span><br><span class="line">NSKeyValueNotifyobserver</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<h4 id="注册监听以后Class应该是NSKVONotifying-lt-ObjectClass-gt-，为什么我们打印calss的时候还是-lt-ObjectClass-gt-？"><a href="#注册监听以后Class应该是NSKVONotifying-lt-ObjectClass-gt-，为什么我们打印calss的时候还是-lt-ObjectClass-gt-？" class="headerlink" title="注册监听以后Class应该是NSKVONotifying_&lt;ObjectClass&gt;，为什么我们打印calss的时候还是&lt;ObjectClass&gt;？"></a>注册监听以后Class应该是<code>NSKVONotifying_&lt;ObjectClass&gt;</code>，为什么我们打印calss的时候还是<code>&lt;ObjectClass&gt;</code>？</h4><p>猜测可能是在<code>NSKVONotifying_&lt;ObjectClass&gt;</code>重载了<code>-(Class)class</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class&#123;</span><br><span class="line">    return class_getSuperclass(object_getClass(self));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除监听以后NSKVONotifying-lt-ObjectClass-gt-存在还是不存在？"><a href="#移除监听以后NSKVONotifying-lt-ObjectClass-gt-存在还是不存在？" class="headerlink" title="移除监听以后NSKVONotifying_&lt;ObjectClass&gt;存在还是不存在？"></a>移除监听以后<code>NSKVONotifying_&lt;ObjectClass&gt;</code>存在还是不存在？</h4><p>在<code>- (void)dealloc</code>中移除观察者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [p removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-bf4485ecb77cf606.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移除监听观察者类是否还存在.png"></p>
<p>然后在打印所有<code>&lt;ObjectClass&gt;</code>的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-06-29 16:14:20.841977+0800 KVO的全面分析[4807:728105] classes = (</span><br><span class="line">    Person3,</span><br><span class="line">    &quot;NSKVONotifying_Person3&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>并没有消失</p>
<h2 id="自定义KVO"><a href="#自定义KVO" class="headerlink" title="自定义KVO"></a>自定义KVO</h2><h3 id="自定义KVO的步骤"><a href="#自定义KVO的步骤" class="headerlink" title="自定义KVO的步骤"></a>自定义KVO的步骤</h3><ol>
<li>定义添加观察者<code>- (void)GG_addObserver:(NSObject *)observer forKeyPath:(NSString *)KeyPath options:(NSKeyValueObservingOptions)options context:(void *)context</code>和移除观察者方法<code>- (void)gv_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath</code></li>
<li>创建一个子类 <code>NSKVONotifying_&lt;Objectclass&gt;</code></li>
<li>动态添加一些方法(setter class)</li>
<li>修改isa的指向</li>
<li>用runtime关联对象方法动态添加观察者server</li>
</ol>
<h4 id="步骤一：定义添加观察者"><a href="#步骤一：定义添加观察者" class="headerlink" title="步骤一：定义添加观察者"></a>步骤一：定义添加观察者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)GG_addObserver:(NSObject *)observer forKeyPath:(NSString *)KeyPath options:(NSKeyValueObservingOptions)options context:(void *)context&#123;</span><br><span class="line">&#125;</span><br><span class="line">/// 移除观察者</span><br><span class="line">- (void)gv_removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="步骤二：在添加观察者方法中创建一个子类-NSKVONotifying-lt-Objectclass-gt"><a href="#步骤二：在添加观察者方法中创建一个子类-NSKVONotifying-lt-Objectclass-gt" class="headerlink" title="步骤二：在添加观察者方法中创建一个子类 NSKVONotifying_&lt;Objectclass&gt;"></a>步骤二：在添加观察者方法中创建一个子类 <code>NSKVONotifying_&lt;Objectclass&gt;</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//1. 拼接子类名  //person</span><br><span class="line">NSString *oldName = NSStringFromClass([self class]);</span><br><span class="line">NSString *newName = [NSString stringWithFormat:@&quot;NSKVONotifying_%@&quot;,oldName];</span><br><span class="line">    </span><br><span class="line">//2. 创建并注册类</span><br><span class="line">Class newclass = NSClassFromString(newName);</span><br><span class="line">if(!newclass)&#123;</span><br><span class="line">    //创建并注册类</span><br><span class="line">    newclass = objc_allocateClassPair([self class], newName.UTF8String, 0);</span><br><span class="line">    objc_registerClassPair(newclass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="步骤三：在添加观察者方法中NSKVONotifying-lt-Objectclass-gt-动态添加一些方法-setter-class"><a href="#步骤三：在添加观察者方法中NSKVONotifying-lt-Objectclass-gt-动态添加一些方法-setter-class" class="headerlink" title="步骤三：在添加观察者方法中NSKVONotifying_&lt;Objectclass&gt;动态添加一些方法(setter class)"></a>步骤三：在添加观察者方法中<code>NSKVONotifying_&lt;Objectclass&gt;</code>动态添加一些方法(setter class)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//添加一些方法</span><br><span class="line">//class</span><br><span class="line">Method classMethod = class_getInstanceMethod([self class], @selector(class));</span><br><span class="line">const char* classTypes = method_getTypeEncoding(classMethod);</span><br><span class="line">class_addMethod(newclass, @selector(class), (IMP)GG_class, classTypes);</span><br><span class="line"></span><br><span class="line">//自定义的class方法</span><br><span class="line">Class GG_class(id self, SEL _cmd)&#123;</span><br><span class="line">    return class_getSuperclass(object_getClass(self));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//setter</span><br><span class="line">NSString *setterMethodName = setterForGetter(keyPath);</span><br><span class="line">SEL setterSEL = NSSelectorFromString(setterMethodName);</span><br><span class="line">Method setterMethod = class_getInstanceMethod([self class], setterSEL);</span><br><span class="line">const char * setterTypes = method_getTypeEncoding(setterMethod);</span><br><span class="line">class_addMethod(newclass, setterSEL, (IMP)GG_setter, setterTypes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义的setter方法</span><br><span class="line">static void GG_setter(id self, SEL _cmd, id newValue) &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    struct objc_super superStruct = &#123;</span><br><span class="line">        self,</span><br><span class="line">        class_getSuperclass(object_getClass(self))</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 改变父类的值</span><br><span class="line">    objc_msgSendSuper(&amp;superStruct, _cmd, newValue);</span><br><span class="line">    </span><br><span class="line">    // 通知观察者， 值发生改变了</span><br><span class="line">    // 观察者</span><br><span class="line">    id observer = objc_getAssociatedObject(self, (__bridge void *)@&quot;objc&quot;);</span><br><span class="line">    NSString* setterName = NSStringFromSelector(_cmd);</span><br><span class="line">    NSString* key = getterForSetter(setterName);</span><br><span class="line">    </span><br><span class="line">    objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:), key, self, @&#123;key:newValue&#125;, nil);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//key ===&gt;&gt;&gt; setKey:</span><br><span class="line">static NSString  * setterForGetter(NSString *getter)&#123;</span><br><span class="line">    </span><br><span class="line">    if (getter.length &lt;= 0) &#123; return nil; &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *firstString = [[getter substringToIndex:1] uppercaseString];</span><br><span class="line">    NSString *leaveString = [getter substringFromIndex:1];</span><br><span class="line">    </span><br><span class="line">    return [NSString stringWithFormat:@&quot;set%@%@:&quot;,firstString,leaveString];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//set&lt;Key&gt;:===&gt; Key</span><br><span class="line">static NSString * getterForSetter(NSString *setter)&#123;</span><br><span class="line">    </span><br><span class="line">    if (setter.length &lt;= 0 || ![setter hasPrefix:@&quot;set&quot;] || ![setter hasSuffix:@&quot;:&quot;]) &#123; return nil;&#125;</span><br><span class="line">    </span><br><span class="line">    NSRange range = NSMakeRange(3, setter.length-4);</span><br><span class="line">    NSString *getter = [setter substringWithRange:range];</span><br><span class="line">    NSString *firstString = [[getter substringToIndex:1] lowercaseString];</span><br><span class="line">    getter = [getter stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:firstString];</span><br><span class="line">    </span><br><span class="line">    return getter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="步骤四：修改isa的指向"><a href="#步骤四：修改isa的指向" class="headerlink" title="步骤四：修改isa的指向"></a>步骤四：修改isa的指向</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_setClass(self, newclass);</span><br></pre></td></tr></table></figure>
<h4 id="步骤五：用runtime关联对象方法动态添加观察者server并在自定义setter方法中实现改变父类的值，并通知观察者"><a href="#步骤五：用runtime关联对象方法动态添加观察者server并在自定义setter方法中实现改变父类的值，并通知观察者" class="headerlink" title="步骤五：用runtime关联对象方法动态添加观察者server并在自定义setter方法中实现改变父类的值，并通知观察者"></a>步骤五：用runtime关联对象方法动态添加观察者server并在自定义setter方法中实现改变父类的值，并通知观察者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 关联方法</span><br><span class="line">objc_setAssociatedObject(self, (__bridge void *)@&quot;objc&quot;, observer, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//setter方法干的内容</span><br><span class="line">static void GG_setter(id self, SEL _cmd, id newValue) &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    struct objc_super superStruct = &#123;</span><br><span class="line">        self,</span><br><span class="line">        class_getSuperclass(object_getClass(self))</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 改变父类的值</span><br><span class="line">    objc_msgSendSuper(&amp;superStruct, _cmd, newValue);</span><br><span class="line">    </span><br><span class="line">    // 通知观察者， 值发生改变了</span><br><span class="line">    // 观察者</span><br><span class="line">    id observer = objc_getAssociatedObject(self, (__bridge void *)@&quot;objc&quot;);</span><br><span class="line">    NSString* setterName = NSStringFromSelector(_cmd);</span><br><span class="line">    NSString* key = getterForSetter(setterName);</span><br><span class="line">    </span><br><span class="line">    objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:), key, self, @&#123;key:newValue&#125;, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义BlockKVO"><a href="#自定义BlockKVO" class="headerlink" title="自定义BlockKVO"></a>自定义BlockKVO</h2><h3 id="自定义BlockKVO的实现步骤"><a href="#自定义BlockKVO的实现步骤" class="headerlink" title="自定义BlockKVO的实现步骤"></a>自定义BlockKVO的实现步骤</h3><ol>
<li><p>在NSObject的分类<code>NSObject+KVO</code>中添加一个block<code>GGKVOBlock</code>和<code>- (void)GG_addobserverrBlock:(NSObject *)observer forkeyPath:(NSString *)keyPath handle:(GGKVOBlock)handleBlock</code>观察者方法</p>
</li>
<li><p>观察者方法方法实现一个存储<code>GGInfo</code>的一个数组，来存储观察者，并使用Runtime方法关联到这个对象当中</p>
</li>
<li>在<code>setter</code>方法方法中获取<code>GGInfo</code>的数组，便利其中回调<code>GGInfo</code>中的block</li>
</ol>
<h3 id="自定义BlockKVO第一步"><a href="#自定义BlockKVO第一步" class="headerlink" title="自定义BlockKVO第一步"></a>自定义BlockKVO第一步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^GGKVOBlock)(id observer,NSString *keyPath,id oldValue, id newValue);</span><br><span class="line">- (void)GG_addobserverrBlock:(NSObject *)observer forkeyPath:(NSString *)keyPath handle:(GGKVOBlock)handleBlock;</span><br></pre></td></tr></table></figure>
<h3 id="自定义BlockKVO第二步"><a href="#自定义BlockKVO第二步" class="headerlink" title="自定义BlockKVO第二步"></a>自定义BlockKVO第二步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static const char* GGKVOAssiociateKey = &quot;GGKVOAssiociateKey&quot;;</span><br><span class="line">@interface GGInfo : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) NSObject* observer;</span><br><span class="line">@property (nonatomic, strong) NSString* keyPath;</span><br><span class="line">@property (nonatomic, copy) GGKVOBlock hanleBlock;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation GGInfo</span><br><span class="line"></span><br><span class="line">- (instancetype) initWithObserver:(NSObject*)observer forKeyPath:(NSString*) keyPath handleBlock:(GGKVOBlock) block &#123;</span><br><span class="line">    if (self == [super init]) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _keyPath = keyPath;</span><br><span class="line">        _hanleBlock = block;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 信息保存</span><br><span class="line">GGInfo* info = [[GGInfo alloc] initWithObserver:observer forKeyPath:keyPath handleBlock:handleBlock];</span><br><span class="line">NSMutableArray* array = objc_getAssociatedObject(self, GGKVOAssiociateKey);</span><br><span class="line">if (!array) &#123;</span><br><span class="line">    array = [NSMutableArray array];</span><br><span class="line">    objc_setAssociatedObject(self, GGKVOAssiociateKey, array, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">[array addObject:info];</span><br></pre></td></tr></table></figure>
<h3 id="自定义BlockKVO第三步"><a href="#自定义BlockKVO第三步" class="headerlink" title="自定义BlockKVO第三步"></a>自定义BlockKVO第三步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static void GG_setter(id self, SEL _cmd, id newValue) &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    struct objc_super superStruct = &#123;</span><br><span class="line">        self,</span><br><span class="line">        class_getSuperclass(object_getClass(self))</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    NSString* keyPath = getterForSetter(NSStringFromSelector(_cmd));</span><br><span class="line"></span><br><span class="line">    id oldValue = objc_msgSendSuper(&amp;superStruct, NSSelectorFromString(keyPath));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 改变父类的值</span><br><span class="line">    objc_msgSendSuper(&amp;superStruct, _cmd, newValue);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray* array = objc_getAssociatedObject(self, GGKVOAssiociateKey);</span><br><span class="line">    if (array) &#123;</span><br><span class="line">        for (GGInfo* info in array) &#123;</span><br><span class="line">            if ([info.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">                info.hanleBlock(info.observer, keyPath, oldValue, newValue);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义KVO自动销毁"><a href="#自定义KVO自动销毁" class="headerlink" title="自定义KVO自动销毁"></a>自定义KVO自动销毁</h2><h3 id="第一种自动销毁的方式"><a href="#第一种自动销毁的方式" class="headerlink" title="第一种自动销毁的方式"></a>第一种自动销毁的方式</h3><ol>
<li>在被观察者对象别名<code>person</code>中添加<code>dealloc</code>方法<ul>
<li>如果不添加<code>dealloc</code>，NSObject-&gt;isa指针会一直往上去寻找，这样你在交换的时候会交换很多次数这个方法</li>
</ul>
</li>
<li>如果需要自动移除观察者，我们必须在<code>person`</code>dealloc`中移除</li>
<li>在对象中自定义<code>Mydealloc</code>并交换其<code>dealloc</code></li>
<li>在<code>Mydealloc</code>移除我们的观察者，从而实现KVO的自动销毁</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">// NSObject dealloc</span><br><span class="line">- (void) dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) hookDealloc &#123;</span><br><span class="line">    Method m1 = class_getInstanceMethod(object_getClass(self), NSSelectorFromString(@&quot;dealloc&quot;));</span><br><span class="line">    Method m2 = class_getInstanceMethod(object_getClass(self), @selector(myDealloc));</span><br><span class="line">    method_exchangeImplementations(m1, m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) myDealloc &#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    Class superClass = class_getSuperclass(object_getClass(self));</span><br><span class="line"></span><br><span class="line">    object_setClass(self, superClass);</span><br><span class="line"></span><br><span class="line">    [self myDealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="第二种自动销毁的方式"><a href="#第二种自动销毁的方式" class="headerlink" title="第二种自动销毁的方式"></a>第二种自动销毁的方式</h3><p>第一种的销毁方式，我们必须要在<code>Person</code>被观察者中实现<code>dealloc</code>方法来实现我们的方法交换，为什么？</p>
<ul>
<li><p>RunLoop在不断的处理事情，中间是由一些临时对象的，当RunLoop休眠或者退出的时候会调用对象的析构函数，而我们在NSObject分类中交换的该方法，所以会出现一只调用的现象，类中的方法是如果查找了，我们可以查看上面isa指向的一个图</p>
</li>
<li><p>所以第二种自动销毁方式就是在新建的子类<code>NSKVONotifying_&lt;Objectclass&gt;</code>中添加<code>dealloc</code>方法。</p>
</li>
</ul>
<p>在我们创建子类<code>NSKVONotifying_&lt;Objectclass&gt;</code>的时候其中添加<code>dealloc</code>析构方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 添加析构方法</span><br><span class="line">SEL deallocSEL = NSSelectorFromString(@&quot;dealloc&quot;);</span><br><span class="line">Method deallocMethod = class_getInstanceMethod([self class], deallocSEL);</span><br><span class="line">const char* deallocTypes = method_getTypeEncoding(deallocMethod);</span><br><span class="line">class_addMethod(newClass, deallocSEL, (IMP)myDealloc, deallocTypes);</span><br></pre></td></tr></table></figure></p>
<h1 id="KVO的概括图"><a href="#KVO的概括图" class="headerlink" title="KVO的概括图"></a>KVO的概括图</h1><p><img src="https://upload-images.jianshu.io/upload_images/7980283-d1e86943ffa54623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KVO的内容.png"></p>

      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/06/29/iOS基础全面分析之三(KVO全面分析)/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
    
<article id="post-iOS基础全面分析之一(KVC全面分析)" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/28/iOS基础全面分析之一(KVC全面分析)/">iOS基础全面分析之一(KVC全面分析)</a>
    </h1>
  

        
        <a href="/2019/06/28/iOS基础全面分析之一(KVC全面分析)/" class="archive-article-date">
  	<time datetime="2019-06-28T15:06:38.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-06-28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="KVC全面分析"><a href="#KVC全面分析" class="headerlink" title="KVC全面分析"></a>KVC全面分析</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li>能够对对象的私有成员进行取值赋值</li>
<li>对数值和结构体的属性进行的打包解包处理 (NSNumber、NSValue)</li>
</ol>
<h2 id="基本赋值过程"><a href="#基本赋值过程" class="headerlink" title="基本赋值过程"></a>基本赋值过程</h2><ol>
<li>先找相关方法： <code>set&lt;key&gt;:, _set&lt;key&gt;:, setIs&lt;key&gt;:</code></li>
<li>若没有相关方法，会调用<code>+ (BOOL)accessInstanceVariablesDirectly</code>方法</li>
<li>如果return是NO，直接执行KVC的<code>[object setValue:forUndefinedKey:]:</code>(系统抛出一个异常，未定义的key)</li>
<li><p><code>+ (BOOL)accessInstanceVariablesDirectly</code>如果return是YES，继续找相关的变量：</p>
<ul>
<li><p>相关变量赋值顺序，</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//_&lt;key&gt;,_is&lt;key&gt;,&lt;key&gt;,is&lt;key&gt;</span><br><span class="line">//    NSString * name;         //3</span><br><span class="line">//    NSString * _name;        //1</span><br><span class="line">//    NSString * isName;       //4</span><br><span class="line">//    NSString * _isName;      //2</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果方法或成员变量都不存在，<code>[object setValue:forUndefinedKey:]:</code>(系统抛出一个异常，未定义的key)</p>
</li>
</ol>
<h2 id="基本取值过程"><a href="#基本取值过程" class="headerlink" title="基本取值过程"></a>基本取值过程</h2><ol>
<li>先找相关方法 <code>get&lt;key&gt;,&lt;key&gt;</code></li>
<li>若没有相关方法，会调用<code>+ (BOOL)accessInstanceVariablesDirectly</code>方法</li>
<li>如果return是NO，执行KVC的<code>[object valueForUndefinedKey:]:</code>(系统抛出一个异常，未定义的key)</li>
<li><p><code>+ (BOOL)accessInstanceVariablesDirectly</code>如果return是YES，继续找相关的变量：</p>
<ul>
<li><p>相关变量取值顺序</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//_&lt;key&gt;,_is&lt;key&gt;,&lt;key&gt;,is&lt;key&gt;</span><br><span class="line">//    NSString * name;         //3</span><br><span class="line">//    NSString * _name;        //1</span><br><span class="line">//    NSString * isName;       //4</span><br><span class="line">//    NSString * _isName;      //2</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方法根成员变量都不存在，执行KVC的<code>[object valueForUndefinedKey:]:</code>(系统抛出一个异常，未定义的key)</p>
</li>
</ol>
<h2 id="KVC自定义"><a href="#KVC自定义" class="headerlink" title="KVC自定义"></a>KVC自定义</h2><h3 id="set方法自定义"><a href="#set方法自定义" class="headerlink" title="set方法自定义"></a>set方法自定义</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"> - (void)tz_setValue:(nullable id)value forKey:(NSString *)key &#123;</span><br><span class="line">   </span><br><span class="line">    // 判断是否合法</span><br><span class="line">    if (key == nil &amp;&amp; key.length == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Key</span><br><span class="line">    NSString* Key = key.capitalizedString;</span><br><span class="line">    </span><br><span class="line">    /// 先找相关方法</span><br><span class="line">    //set&lt;Key&gt;:, _set&lt;Key&gt;:, setIs&lt;Key&gt;:</span><br><span class="line">    NSString* setKey = [NSString stringWithFormat:@&quot;set%@:&quot;, Key];</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(setKey)]) &#123;</span><br><span class="line">        [self performSelector:NSSelectorFromString(setKey) withObject:value];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString* _setKey = [NSString stringWithFormat:@&quot;_set%@:&quot;, Key];</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(_setKey)]) &#123;</span><br><span class="line">        [self performSelector:NSSelectorFromString(_setKey) withObject:value];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString* setIsKey = [NSString stringWithFormat:@&quot;setIs%@:&quot;, Key];</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(setIsKey)]) &#123;</span><br><span class="line">        [self performSelector:NSSelectorFromString(setIsKey) withObject:value];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">        NSException* exception = [NSException exceptionWithName:@&quot;NSUnkonwnKeyException&quot; reason:@&quot;setValue:forUndefineKey&quot; userInfo:nil];</span><br><span class="line">        @throw exception;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 再找相关变量</span><br><span class="line">    /// 获取所以成员变量</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar* ivars = class_copyIvarList([self class], &amp;count);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray* arr = [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar var = ivars[i];</span><br><span class="line">        const char* varName = ivar_getName(var);</span><br><span class="line">        NSString* name = [NSString stringWithUTF8String:varName];</span><br><span class="line">        [arr addObject:name];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NSString* keyName = arr[i];</span><br><span class="line">        if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;_%@&quot;, key]]) &#123;</span><br><span class="line">            object_setIvar(self, ivars[i], value);</span><br><span class="line">            free(ivars);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NSString* keyName = arr[i];</span><br><span class="line">        if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;__is%@&quot;, Key]]) &#123;</span><br><span class="line">            object_setIvar(self, ivars[i], value);</span><br><span class="line">            free(ivars);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NSString* keyName = arr[i];</span><br><span class="line">        if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;%@&quot;, key]]) &#123;</span><br><span class="line">            object_setIvar(self, ivars[i], value);</span><br><span class="line">            free(ivars);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NSString* keyName = arr[i];</span><br><span class="line">        if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;is%@&quot;, Key]]) &#123;</span><br><span class="line">            object_setIvar(self, ivars[i], value);</span><br><span class="line">            free(ivars);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self setValue:value forUndefinedKey:key];</span><br><span class="line">    free(ivars);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get方法自定义"><a href="#get方法自定义" class="headerlink" title="get方法自定义"></a>get方法自定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)GG_getValueforKey:(NSString *)key&#123;</span><br><span class="line">    </span><br><span class="line">    // 判断是否合法</span><br><span class="line">    if (key == nil &amp;&amp; key.length == 0) &#123;</span><br><span class="line">        NSException* exception = [NSException exceptionWithName:@&quot;崩溃&quot; reason:@&quot;value不合法&quot; userInfo:nil];</span><br><span class="line">        @throw exception;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Key</span><br><span class="line">    NSString* CapitalKey = key.capitalizedString;</span><br><span class="line">    </span><br><span class="line">    //get&lt;key&gt;,&lt;key&gt;</span><br><span class="line">    NSString* getKey = [NSString stringWithFormat:@&quot;get%@&quot;, CapitalKey];</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123;</span><br><span class="line">        </span><br><span class="line">        return [self performSelector:NSSelectorFromString(getKey)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString* Key = [NSString stringWithFormat:@&quot;%@&quot;, key];</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(Key)]) &#123;</span><br><span class="line">        </span><br><span class="line">        return [self performSelector:NSSelectorFromString(Key)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (![self.class accessInstanceVariablesDirectly]) &#123;</span><br><span class="line">        NSException* exception = [NSException exceptionWithName:@&quot;NSUnkonwnKeyException&quot; reason:@&quot;valueForUndefinedKey:&quot; userInfo:nil];</span><br><span class="line">        @throw exception;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#pragma mark -- 获取所以成员变量</span><br><span class="line">    /// 再找相关变量</span><br><span class="line">    /// 获取所以成员变量</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar* ivars = class_copyIvarList([self class], &amp;count);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray* arr = [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar var = ivars[i];</span><br><span class="line">        const char* varName = ivar_getName(var);</span><br><span class="line">        NSString* name = [NSString stringWithUTF8String:varName];</span><br><span class="line">        NSLog(@&quot;%@&quot;,name);</span><br><span class="line">        [arr addObject:name];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // _&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NSString* keyName = arr[i];</span><br><span class="line">        if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;_%@&quot;, key]]) &#123;</span><br><span class="line">            NSString * var = object_getIvar(self, ivars[i]);</span><br><span class="line">            free(ivars);</span><br><span class="line">            return var;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NSString* keyName = arr[i];</span><br><span class="line">        if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;_is%@&quot;, CapitalKey]]) &#123;</span><br><span class="line">            NSString * var = object_getIvar(self, ivars[i]);</span><br><span class="line">            free(ivars);</span><br><span class="line">            return var;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NSString* keyName = arr[i];</span><br><span class="line">        if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;%@&quot;, key]]) &#123;</span><br><span class="line">            NSString * var = object_getIvar(self, ivars[i]);</span><br><span class="line">            free(ivars);</span><br><span class="line">            return var;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NSString* keyName = arr[i];</span><br><span class="line">        if ([keyName isEqualToString:[NSString stringWithFormat:@&quot;is%@&quot;, CapitalKey]]) &#123;</span><br><span class="line">            NSString * var = object_getIvar(self, ivars[i]);</span><br><span class="line">            free(ivars);</span><br><span class="line">            return var;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *RNstr = [self valueForUndefinedKey:key];</span><br><span class="line">    </span><br><span class="line">    free(ivars);</span><br><span class="line">    return  RNstr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KVC异常处理及正确性验证"><a href="#KVC异常处理及正确性验证" class="headerlink" title="KVC异常处理及正确性验证"></a>KVC异常处理及正确性验证</h2><h3 id="非对象类型，KVC的异常处理"><a href="#非对象类型，KVC的异常处理" class="headerlink" title="非对象类型，KVC的异常处理"></a>非对象类型，KVC的异常处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property(nonatomic,copy)NSString *name;</span><br><span class="line">@property(nonatomic,assign)NSInteger age;</span><br><span class="line">@end</span><br><span class="line">Person *per = [[Person alloc]init];</span><br><span class="line">//这里会崩溃，因为下面是一个值类型，而值类型不能为nil，所以会崩溃</span><br><span class="line">/*</span><br><span class="line">Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;[&lt;Person 0x600003865380&gt; setNilValueForKey]: could not set nil as the value for the key age.&apos;</span><br><span class="line">*/</span><br><span class="line">[per setValue:nil forKey:@&quot;age&quot;];</span><br></pre></td></tr></table></figure>
<p>上述是值类型用KVC赋值为nil崩溃，怎样才能不崩溃呐？<br>需要在<code>Person</code>重写<code>setNilValueForKey</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//非对象类型，不能为nil</span><br><span class="line">- (void)setNilValueForKey:(NSString *)key&#123;</span><br><span class="line">    NSLog(@&quot;%@,值不能为空&quot;,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取值和赋值key不存在的异常捕获"><a href="#取值和赋值key不存在的异常捕获" class="headerlink" title="取值和赋值key不存在的异常捕获"></a>取值和赋值key不存在的异常捕获</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//赋值异常捕获</span><br><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;</span><br><span class="line">    NSLog(@&quot;key == %@ 值不存在&quot;,key);</span><br><span class="line">&#125;</span><br><span class="line">//取值的异常捕获</span><br><span class="line">- (id)valueForUndefinedKey:(NSString *)key&#123;</span><br><span class="line">    NSLog(@&quot;key == %@ 值不存在&quot;,key);</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>扩展：万能容器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;</span><br><span class="line">    </span><br><span class="line">    if(!key || [key isEqualToString:@&quot;&quot;])&#123;</span><br><span class="line">        Persondict = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    [Persondict setValue:value forUndefinedKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)valueForUndefinedKey:(NSString *)key&#123;</span><br><span class="line">    if(!key || [key isEqualToString:@&quot;&quot;])&#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return [Persondict objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="value正确性验证"><a href="#value正确性验证" class="headerlink" title="value正确性验证"></a>value正确性验证</h3><p><code>- (BOOL)validateValue: forKey: error:，- (BOOL)validateValue: forKeyPath: error:</code>,这两个方法是KVC提供的验证值的正确性的方法</p>
<ol>
<li>值所对应的验证方法是否实现，- (BOOL)validate<key>: forKey: error:</key></li>
<li>如果实现了就会根据实现方法里面的自定义逻辑返回YES和NO，如果没有实现这个方法，则默认系统会返回YES</li>
</ol>
<p>例子：存储一个<code>Int</code>类型age，这个值必须<code>0&lt;age&lt;200</code>，如果不符合逻辑返回NO，不赋值给<code>person</code>对象。如果符合就赋值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (BOOL)validateAge:(inout id  _Nullable __autoreleasing *)ioValue error:(out NSError * _Nullable __autoreleasing *)outError&#123;</span><br><span class="line">    </span><br><span class="line">    NSInteger value = [(NSNumber *) * ioValue integerValue];</span><br><span class="line">    if(value &lt;=0 || value&gt;=200)&#123;</span><br><span class="line">        return  NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//正确性验证</span><br><span class="line">NSNumber *value = @200;</span><br><span class="line">Person *per = [[Person alloc]init];</span><br><span class="line">if([per validateValue:&amp;value forKey:@&quot;age&quot; error:NULL])&#123;</span><br><span class="line">    [per setValue:value forKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KVC进阶使用"><a href="#KVC进阶使用" class="headerlink" title="KVC进阶使用"></a>KVC进阶使用</h2><h3 id="KVC与字典"><a href="#KVC与字典" class="headerlink" title="KVC与字典"></a>KVC与字典</h3><h4 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h4><p>通过一个字典，以字典Key为属性名称直接赋值给<code>model</code>,一种字典转模型的模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property(nonatomic,copy)NSString *name;</span><br><span class="line">@property(nonatomic,assign)NSInteger age;</span><br><span class="line">@property(nonatomic,copy)NSString *nick;</span><br><span class="line">@property(nonatomic,assign)float height;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NSDictionary *dict = @&#123;</span><br><span class="line">                       @&quot;name&quot;:@&quot;struggle3g&quot;,</span><br><span class="line">                       @&quot;age&quot;:@18,</span><br><span class="line">                       @&quot;nick&quot;:@&quot;cat&quot;,</span><br><span class="line">                       @&quot;height&quot;:@170</span><br><span class="line">                       &#125;;</span><br><span class="line">    </span><br><span class="line">Person *per = [[Person alloc]init];</span><br><span class="line">[per setValuesForKeysWithDictionary:dict];</span><br><span class="line">    NSLog(@&quot;per.name = %@, per.age = %d, per.nick =%@, per.height = %f&quot;, per.name, per.age, per.nick, per.height);</span><br></pre></td></tr></table></figure>
<h4 id="通过一组key获取字典"><a href="#通过一组key获取字典" class="headerlink" title="通过一组key获取字典"></a>通过一组key获取字典</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSArray* keys = @[@&quot;name&quot;, @&quot;age&quot;];</span><br><span class="line">NSDictionary* dict1 = [p dictionaryWithValuesForKeys:keys];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%@&quot;, dict1);</span><br></pre></td></tr></table></figure>
<h3 id="NSArray使用valueForKey-向所有的成员发送消息-KVC消息传递"><a href="#NSArray使用valueForKey-向所有的成员发送消息-KVC消息传递" class="headerlink" title="NSArray使用valueForKey:向所有的成员发送消息 (KVC消息传递)"></a>NSArray使用valueForKey:向所有的成员发送消息 (KVC消息传递)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)arrayKVCtext&#123;</span><br><span class="line">    </span><br><span class="line">//向这个数组里面的所有方法发送消息</span><br><span class="line">NSArray *arr = @[@&quot;Mondy&quot;,@&quot;Tuesday&quot;,@&quot;Wednesday&quot;];</span><br><span class="line">NSArray *lengtharr = [arr valueForKey:@&quot;length&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,lengtharr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KVC容器操作"><a href="#KVC容器操作" class="headerlink" title="KVC容器操作"></a>KVC容器操作</h3><h4 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a><strong>聚合操作</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*聚合操作*/</span><br><span class="line">    </span><br><span class="line">NSMutableArray *students = [[NSMutableArray alloc]init];</span><br><span class="line">for (int i = 0; i&lt;6; i++) &#123;</span><br><span class="line">    Person *per = [Person new];</span><br><span class="line">    NSDictionary *dict = @&#123;</span><br><span class="line">                           @&quot;name&quot;:@&quot;struggle3g&quot;,</span><br><span class="line">                           @&quot;age&quot;:@(18+i),</span><br><span class="line">                           @&quot;nick&quot;:@&quot;cat&quot;,</span><br><span class="line">                           @&quot;height&quot;:@(1.70+0.02*arc4random_uniform(6))</span><br><span class="line">                           &#125;;</span><br><span class="line">    [per setValuesForKeysWithDictionary:dict];</span><br><span class="line">    [students addObject:per];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%@&quot;,[students valueForKey:@&quot;height&quot;]);</span><br><span class="line">//平均身高</span><br><span class="line">   </span><br><span class="line">/*</span><br><span class="line"> //聚合的公式，这个在下面官网有注解 https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html#//apple_ref/doc/uid/20002176-SW5</span><br><span class="line"> </span><br><span class="line"> */</span><br><span class="line">float avg = [[students valueForKeyPath:@&quot;@avg.height&quot;] floatValue];</span><br><span class="line">NSLog(@&quot;%f&quot;,avg);</span><br></pre></td></tr></table></figure>
<h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)arrayKVCtext&#123;</span><br><span class="line">    </span><br><span class="line">    //向这个数组里面的所有方法发送消息</span><br><span class="line">    NSArray *arr = @[@&quot;Mondy&quot;,@&quot;Tuesday&quot;,@&quot;Wednesday&quot;];</span><br><span class="line">    NSArray *lengtharr = [arr valueForKey:@&quot;length&quot;];</span><br><span class="line">    NSLog(@&quot;%@&quot;,lengtharr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套操作-array-amp-set-操作"><a href="#嵌套操作-array-amp-set-操作" class="headerlink" title="嵌套操作(array&amp;set)操作"></a>嵌套操作(array&amp;set)操作</h4><h5 id="嵌套操作array"><a href="#嵌套操作array" class="headerlink" title="嵌套操作array"></a>嵌套操作array</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/// 嵌套集合(array&amp;set)操作 @distinctUnionOfArrays @unionOfArrays @distinctUnionOfSets</span><br><span class="line">- (void) containerNestingTest &#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray* students = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        Person* student = [Person new];</span><br><span class="line">        NSDictionary* dict = @&#123;</span><br><span class="line">                               @&quot;name&quot;:@&quot;Tom&quot;,</span><br><span class="line">                               @&quot;age&quot;:@(18+i),</span><br><span class="line">                               @&quot;nick&quot;:@&quot;Cat&quot;,</span><br><span class="line">                               @&quot;height&quot;:@(1.65 + 0.02*arc4random_uniform(6)),</span><br><span class="line">                               &#125;;</span><br><span class="line">        [student setValuesForKeysWithDictionary:dict];</span><br><span class="line">        [students addObject:student];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray* students1 = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        Person* student = [Person new];</span><br><span class="line">        NSDictionary* dict = @&#123;</span><br><span class="line">                               @&quot;name&quot;:@&quot;Tom&quot;,</span><br><span class="line">                               @&quot;age&quot;:@(18+i),</span><br><span class="line">                               @&quot;nick&quot;:@&quot;Cat&quot;,</span><br><span class="line">                               @&quot;height&quot;:@(1.65 + 0.02*arc4random_uniform(6)),</span><br><span class="line">                               &#125;;</span><br><span class="line">        [student setValuesForKeysWithDictionary:dict];</span><br><span class="line">        [students1 addObject:student];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 嵌套数组</span><br><span class="line">    NSArray* nestArr = @[students, students1];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSArray* arr = [nestArr valueForKeyPath:@&quot;@distinctUnionOfArrays.height&quot;];</span><br><span class="line">    NSLog(@&quot;arr = %@&quot;, arr);</span><br><span class="line">    </span><br><span class="line">    NSArray* arr1 = [nestArr valueForKeyPath:@&quot;@unionOfArrays.height&quot;];</span><br><span class="line">    NSLog(@&quot;arr1 = %@&quot;, arr1);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="嵌套操作set"><a href="#嵌套操作set" class="headerlink" title="嵌套操作set"></a>嵌套操作set</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//无序的嵌套集合</span><br><span class="line">- (void) containerNestingTest1&#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableSet* students = [NSMutableSet set];</span><br><span class="line">    for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        Person* student = [Person new];</span><br><span class="line">        NSDictionary* dict = @&#123;</span><br><span class="line">                               @&quot;name&quot;:@&quot;Tom&quot;,</span><br><span class="line">                               @&quot;age&quot;:@(18+i),</span><br><span class="line">                               @&quot;nick&quot;:@&quot;Cat&quot;,</span><br><span class="line">                               @&quot;height&quot;:@(1.65 + 0.02*arc4random_uniform(6)),</span><br><span class="line">                               &#125;;</span><br><span class="line">        [student setValuesForKeysWithDictionary:dict];</span><br><span class="line">        [students addObject:student];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSMutableSet* students1 = [NSMutableSet set];</span><br><span class="line">    for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        Person* student = [Person new];</span><br><span class="line">        NSDictionary* dict = @&#123;</span><br><span class="line">                               @&quot;name&quot;:@&quot;Tom&quot;,</span><br><span class="line">                               @&quot;age&quot;:@(18+i),</span><br><span class="line">                               @&quot;nick&quot;:@&quot;Cat&quot;,</span><br><span class="line">                               @&quot;height&quot;:@(1.65 + 0.02*arc4random_uniform(6)),</span><br><span class="line">                               &#125;;</span><br><span class="line">        [student setValuesForKeysWithDictionary:dict];</span><br><span class="line">        [students1 addObject:student];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //set这个无序集合，向每一个成员发送消息，返回的值是默认是去重的</span><br><span class="line">    NSLog(@&quot;students = %@&quot;,[students valueForKey:@&quot;height&quot;]);</span><br><span class="line">    NSLog(@&quot;students1 = %@&quot;,[students1 valueForKey:@&quot;height&quot;]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSSet *set = [NSSet setWithObjects:students,students1, nil];</span><br><span class="line">    NSArray *arr1 = [set valueForKeyPath:@&quot;@distinctUnionOfSets.height&quot;];</span><br><span class="line">    NSLog(@&quot;%@&quot;,arr1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合代理对象"><a href="#集合代理对象" class="headerlink" title="集合代理对象"></a>集合代理对象</h3><h4 id="Array的集合代理对象"><a href="#Array的集合代理对象" class="headerlink" title="Array的集合代理对象"></a>Array的集合代理对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic,assign)NSUInteger count;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">#pragma  mark -- 集合代理对象</span><br><span class="line"></span><br><span class="line">- (NSUInteger)countOfBooks&#123;</span><br><span class="line">    </span><br><span class="line">    return self.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(id)objectInBooksAtIndex:(NSUInteger)index&#123;</span><br><span class="line">    </span><br><span class="line">    return [NSString stringWithFormat:@&quot;book %lu&quot;,index];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">/*array集合代理对象  一对多的关系  array是2个方法*/</span><br><span class="line">Person *p = [[Person alloc]init];</span><br><span class="line">p.count = 5;</span><br><span class="line">NSLog(@&quot;books = %@&quot;,[p valueForKey:@&quot;books&quot;]);</span><br></pre></td></tr></table></figure>
<h4 id="Set的集合代理对象"><a href="#Set的集合代理对象" class="headerlink" title="Set的集合代理对象"></a>Set的集合代理对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic,strong)NSMutableArray *penArr;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">#pragma  mark -- 集合代理对象</span><br><span class="line"></span><br><span class="line">//个数</span><br><span class="line">- (NSUInteger)countOfPens&#123;</span><br><span class="line">    return [self.penArr count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//是否包含这个成员对象</span><br><span class="line">- (id)memberOfPens:(id)object&#123;</span><br><span class="line">    return [self.penArr containsObject:object]?object:nil;</span><br><span class="line">&#125;</span><br><span class="line">//迭代器</span><br><span class="line">-(id)enumeratorOfPens&#123;</span><br><span class="line">    return [self.penArr reverseObjectEnumerator];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">/*set集合代理对象  set是3个方法*/</span><br><span class="line">p.penArr = [NSMutableArray arrayWithObjects:@&quot;pen0&quot;,@&quot;pen1&quot;,@&quot;pen2&quot;, nil];</span><br><span class="line">NSSet *set = [p valueForKey:@&quot;pens&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,set);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://upload-images.jianshu.io/upload_images/7980283-cc99aeaeec87f3dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KVC的思维导图.png"></p>

      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/06/28/iOS基础全面分析之一(KVC全面分析)/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
    
<article id="post-iOS基础全面分析之二(RunLoop全面分析)" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/28/iOS基础全面分析之二(RunLoop全面分析)/">iOS基础全面分析之二(RunLoop全面分析)</a>
    </h1>
  

        
        <a href="/2019/06/28/iOS基础全面分析之二(RunLoop全面分析)/" class="archive-article-date">
  	<time datetime="2019-06-28T07:23:25.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-06-28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RunLoop全面分析"><a href="#RunLoop全面分析" class="headerlink" title="RunLoop全面分析"></a>RunLoop全面分析</h1><h2 id="什么是RunLoop？"><a href="#什么是RunLoop？" class="headerlink" title="什么是RunLoop？"></a>什么是RunLoop？</h2><p><strong>字面的意思：</strong></p>
<ul>
<li>运行循环，程序运行过程中循环的处理事情</li>
</ul>
<p><strong>iOS中实际含义：</strong></p>
<ul>
<li>实际上是一个对象，这个对象提供一个入口函数，执行这个入口函数后，程序会进入一个while循环，循环的处理一些事情</li>
</ul>
<p>例如：在<code>main.m</code>文件中如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        id ret = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">        NSLog(@&quot;hello&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行时打印不到<code>hello</code>的，因为程序会一直在UIApplicationMain()这个RunLoop的运行循环中。</p>
<h2 id="RunLoop在开发中的作用？"><a href="#RunLoop在开发中的作用？" class="headerlink" title="RunLoop在开发中的作用？"></a>RunLoop在开发中的作用？</h2><h3 id="基本作用"><a href="#基本作用" class="headerlink" title="基本作用"></a>基本作用</h3><ol>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件(触摸、定时器、PerformSelector)</li>
<li>节省CPU资源、提高程序性能，该工作的时候工作，该休息的时候休息</li>
</ol>
<h2 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h2><p><code>CFRunLoop</code> 是基于 <code>pthread</code> 来管理的,开源代码的逻辑大概是下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">/// 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line">/// 获取一个 pthread 对应的 RunLoop。</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 直接从 Dictionary 里获取。</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        /// 取不到时，创建一个</span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，线程和RunLoop是一一对应的，其关系是保存在一个全局Dictionary中：</p>
<ol>
<li>线程刚刚创建时并没有RunLoop，如果你不主动获取，那么它就不会创建。</li>
<li>线程的Runloop的创建是发生在第一次获取时。</li>
<li>RunLoop的销毁时发生在线程结束时。</li>
<li>你只能在一个线程的内部获取RunLoop(主线程除外)</li>
</ol>
<h2 id="RunLoop对外的对象和接口"><a href="#RunLoop对外的对象和接口" class="headerlink" title="RunLoop对外的对象和接口"></a>RunLoop对外的对象和接口</h2><h3 id="iOS的RunLoop的对象"><a href="#iOS的RunLoop的对象" class="headerlink" title="iOS的RunLoop的对象"></a>iOS的RunLoop的对象</h3><ol>
<li>NSRunLoop           Foundation框架  基于CFRunLoopRef的封装</li>
<li>CFRunLoopRef        Core Foundation框架<ul>
<li><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CFRunLoopRef</a>开源了一部分代码，可以去查看.</li>
</ul>
</li>
</ol>
<h3 id="CFRunLoopRef的相关核心对象"><a href="#CFRunLoopRef的相关核心对象" class="headerlink" title="CFRunLoopRef的相关核心对象"></a>CFRunLoopRef的相关核心对象</h3><ol>
<li>CFRunLoopRef                  <ul>
<li>RunLoop的对象</li>
</ul>
</li>
<li>CFRunLoopModeRef              <ul>
<li>RunLoop的模式</li>
</ul>
</li>
<li>CFRunLoopSourceRef            <ul>
<li>RunLoop的源</li>
</ul>
</li>
<li>CFRunLoopTimerRef             <ul>
<li>RunLoop时间</li>
</ul>
</li>
<li>CFRunLoopobserverRef          <ul>
<li>RunLoop的观察者</li>
</ul>
</li>
</ol>
<h3 id="CFRunLoopRef核心对象的关系"><a href="#CFRunLoopRef核心对象的关系" class="headerlink" title="CFRunLoopRef核心对象的关系"></a>CFRunLoopRef核心对象的关系</h3><p>其中<code>CFRunLoopModeRef</code>并没有对外包喽，只是通过<code>CFRunLoopRef</code>的接口进行了封装，它们的关系如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-528416248d9ee771.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runloop核心对象关系.png"></p>
<h3 id="CFRunLoopRef核心对象的详解"><a href="#CFRunLoopRef核心对象的详解" class="headerlink" title="CFRunLoopRef核心对象的详解"></a>CFRunLoopRef核心对象的详解</h3><p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1：</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h3 id="CFRunLoop"><a href="#CFRunLoop" class="headerlink" title="CFRunLoop"></a>CFRunLoop</h3><h4 id="CFRunLoop-的结构"><a href="#CFRunLoop-的结构" class="headerlink" title="CFRunLoop 的结构"></a>CFRunLoop 的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // 一个Mode通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // 当前mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="CommonModes"><a href="#CommonModes" class="headerlink" title="CommonModes:"></a><strong>CommonModes:</strong></h4><p>CommonModes表示：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>举个例子：</p>
<p>在主线程有两个 mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。<br>这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>
<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h4 id="commonModeItems"><a href="#commonModeItems" class="headerlink" title="_commonModeItems:"></a><strong>_commonModeItems:</strong></h4><p>这里面主要包括了&lt;Source/Observer/Timer&gt;这些源信息</p>
<h4 id="currentMode"><a href="#currentMode" class="headerlink" title="_currentMode"></a><strong>_currentMode</strong></h4><p>当前RunLoop使用的mode</p>
<h4 id="modes"><a href="#modes" class="headerlink" title="_modes"></a><strong>_modes</strong></h4><p>这个时RunLoop中注册了哪些mode。</p>
<h3 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a>CFRunLoopMode</h3><h4 id="CFRunLoopMode-的结构"><a href="#CFRunLoopMode-的结构" class="headerlink" title="CFRunLoopMode 的结构"></a>CFRunLoopMode 的结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>_name</strong></p>
<p>RunLoopMode的名称</p>
<p><strong>_sources0</strong></p>
<ul>
<li>触摸事件</li>
<li>自定义输入源</li>
<li>perFormSelector:onThread:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopSourceContext context = &#123;</span><br><span class="line">    0,</span><br><span class="line">    NULL,</span><br><span class="line">    NULL,</span><br><span class="line">    NULL,</span><br><span class="line">    NULL,</span><br><span class="line">    NULL,</span><br><span class="line">    NULL,</span><br><span class="line">    schedule,</span><br><span class="line">    cancel,</span><br><span class="line">    perform</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">CFRunLoopSourceRef source0 = CFRunLoopSourceCreate(CFAllocatorGetDefault(), 0, &amp;context);</span><br><span class="line">CFRunLoopAddSource(CFRunLoopGetCurrent(), source0, kCFRunLoopDefaultMode);</span><br><span class="line">    </span><br><span class="line">//</span><br><span class="line">//    CFRunLoopSourceSignal(source0);  //触发源 会调用perform</span><br><span class="line">//    CFRunLoopWakeUp(CFRunLoopGetCurrent());  //唤醒线程</span><br><span class="line">    </span><br><span class="line">//删除源 会调用cancel</span><br><span class="line">//    CFRunLoopRemoveSource(CFRunLoopGetCurrent(), source0, kCFRunLoopDefaultMode);</span><br><span class="line">CFRelease(source0);</span><br><span class="line"></span><br><span class="line">void schedule(void *info, CFRunLoopRef rl, CFRunLoopMode mode) &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cancel(void *info, CFRunLoopRef rl, CFRunLoopMode mode) &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void perform(void *info) &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义源，在runloop添加这个源的时候会调用<code>schedule</code>，<code>CFRunLoopSourceSignal</code>触发会调用<code>perform</code>，<code>CFRunLoopRemoveSource</code>删除会调用<code>cancel</code></p>
<p><strong>_sources1</strong></p>
<p>负责App内部事件，由App负责管理触发，例如UITouch事件，Source1除了包含回调指针外包含一个mach port，和Source0需要手动触发不同，Source1可以监听系统端口和其他线程相互发送消息，它能够主动唤醒RunLoop(由操作系统内核进行管理，例如CFMessagePort消息)。</p>
<ul>
<li>端口(Port)</li>
</ul>
<p>线程间通信的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController () &lt;NSPortDelegate&gt;</span><br><span class="line">@property (nonatomic, strong) NSPort* subThreadPort;</span><br><span class="line">@property (nonatomic, strong) NSPort* mainThreadPort;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.mainThreadPort = [NSPort port];</span><br><span class="line">    self.mainThreadPort.delegate = self;</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:self.mainThreadPort forMode:NSDefaultRunLoopMode];</span><br><span class="line">    [self task];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) task &#123;</span><br><span class="line">    NSThread* thread = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">        self.subThreadPort = [NSPort port];</span><br><span class="line">        self.subThreadPort.delegate = self;</span><br><span class="line">        </span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:self.subThreadPort forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;];</span><br><span class="line">    [thread setName:@&quot;子线程&quot;];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handlePortMessage:(id)message &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    if (![[NSThread currentThread] isMainThread]) &#123;</span><br><span class="line">        NSMutableArray* sendComponents = [NSMutableArray array];</span><br><span class="line">        NSData* data = [@&quot;world&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        [sendComponents addObject:data];</span><br><span class="line">        [self.mainThreadPort sendBeforeDate:[NSDate date] components:sendComponents from:self.subThreadPort reserved:0];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSMutableArray* components = [message valueForKey:@&quot;components&quot;];</span><br><span class="line">    </span><br><span class="line">    if ([components count] &gt; 0) &#123;</span><br><span class="line">        NSData* data = [components objectAtIndex:0];</span><br><span class="line">        NSString* str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">        NSLog(@&quot;%@&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray* components = [NSMutableArray array];</span><br><span class="line">    NSData* data = [@&quot;hello&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    [components addObject:data];</span><br><span class="line">    </span><br><span class="line">    [self.subThreadPort sendBeforeDate:[NSDate date] components:components from:self.mainThreadPort reserved:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>_observers</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopObserver &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;      /* immutable */</span><br><span class="line">    CFIndex _order;         /* immutable */</span><br><span class="line">    CFRunLoopObserverCallBack _callout; /* immutable */</span><br><span class="line">    CFRunLoopObserverContext _context;  /* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它相当于消息循环中的一个监听器，随时通知外部当前RunLoop的运行状态（它包含一个函数指针<em>callout</em>将当前状态及时告诉观察者）。具体的Observer状态如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0), // 进入RunLoop </span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将开始Timer处理</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将开始Source处理</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //从休眠状态唤醒</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7), //退出RunLoop</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void) observerTest &#123;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        NSLog(@&quot;%lu&quot;, activity);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>_timers</strong></p>
<ul>
<li>NSTimer</li>
<li>performSelector:withObject:afterDelay</li>
</ul>
<p>timers的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void) timerTest &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   CFRunLoopTimerRef timer =  CFRunLoopTimerCreateWithHandler(kCFAllocatorDefault, 0, 1, 0, 0, ^(CFRunLoopTimerRef timer) &#123;</span><br><span class="line">       NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    CFRunLoopAddTimer(CFRunLoopGetCurrent(), timer, kCFRunLoopDefaultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RunLoop的一些回调"><a href="#RunLoop的一些回调" class="headerlink" title="RunLoop的一些回调"></a>RunLoop的一些回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// main  dispatch queue</span><br><span class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><br><span class="line"></span><br><span class="line">// __CFRunLoopDoObservers</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><br><span class="line"></span><br><span class="line">// __CFRunLoopDoBlocks</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><br><span class="line"></span><br><span class="line">// __CFRunLoopDoSources0</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><br><span class="line"></span><br><span class="line">// __CFRunLoopDoSource1</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><br><span class="line"></span><br><span class="line">// __CFRunLoopDoTimers</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><br></pre></td></tr></table></figure>
<h2 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h2><p><img src="https://upload-images.jianshu.io/upload_images/7980283-7ff752843128d22f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop循环.png"></p>
<p>其内部代码整理如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">    </span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line"> </span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// • 一个基于 port 的Source 的事件。</span><br><span class="line">            /// • 一个 Timer 到时间了</span><br><span class="line">            /// • RunLoop 自身的超时时间到了</span><br><span class="line">            /// • 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h2 id="RunLoop-的一个思维导图"><a href="#RunLoop-的一个思维导图" class="headerlink" title="RunLoop 的一个思维导图"></a>RunLoop 的一个思维导图</h2><p><img src="https://upload-images.jianshu.io/upload_images/7980283-6bc124ff38aa72d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop.png"></p>
<h2 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h2><p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_5.png" alt="mach"></p>
<h2 id="苹果用RunLoop实现的功能"><a href="#苹果用RunLoop实现的功能" class="headerlink" title="苹果用RunLoop实现的功能"></a>苹果用RunLoop实现的功能</h2><p>首先我们可以看一下App启动后的RunLoop的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    common mode items = &#123;</span><br><span class="line"> </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，系统默认注册了5个Mode:</p>
<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>
<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。<ul>
<li>kCFRunLoopCommonModes（NSRunLoopCommonModes）,其实这个并不是某种具体的Mode，而是一种模式组合，在iOS系统中默认包含了<br>NSDefaultRunLoopMode和 UITrackingRunLoopMode（注意：并不是说Runloop会运行在kCFRunLoopCommonModes这种模式下，而是相当于分别注册了 NSDefaultRunLoopMode和 UITrackingRunLoopMode。当然你也可以通过调用CFRunLoopAddCommonMode()方法将自定义Mode放到 kCFRunLoopCommonModes组合）。</li>
</ul>
</li>
</ol>
<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /// 1. 通知Observers，即将进入RunLoop</span><br><span class="line">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    do &#123;</span><br><span class="line"> </span><br><span class="line">        /// 2. 通知 Observers: 即将触发 Timer 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        /// 4. 触发 Source0 (非基于port的) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        /// 6. 通知Observers，即将进入休眠</span><br><span class="line">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line"> </span><br><span class="line">        /// 7. sleep to wait msg.</span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        /// 8. 通知Observers，线程被唤醒</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line"> </span><br><span class="line">        /// 9. 如果是被Timer唤醒的，回调Timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line"> </span><br><span class="line">        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125; while (...);</span><br><span class="line"> </span><br><span class="line">    /// 10. 通知Observers，即将退出RunLoop</span><br><span class="line">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Runloop和AutoreleasePool"><a href="#Runloop和AutoreleasePool" class="headerlink" title="Runloop和AutoreleasePool"></a>Runloop和AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="RunLoop和事件响应"><a href="#RunLoop和事件响应" class="headerlink" title="RunLoop和事件响应"></a>RunLoop和事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="RunLoop和手势识别"><a href="#RunLoop和手势识别" class="headerlink" title="RunLoop和手势识别"></a>RunLoop和手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="RunLoop和界面更新"><a href="#RunLoop和界面更新" class="headerlink" title="RunLoop和界面更新"></a>RunLoop和界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>
<h3 id="RunLoop和定时器"><a href="#RunLoop和定时器" class="headerlink" title="RunLoop和定时器"></a>RunLoop和定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>NStimer 不准时的原因</p>
<ol>
<li>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。也就是说RunLoop循环处理的这个时间</li>
<li>Mode变化，也会让定时器不准</li>
</ol>
<p>GCDtimer比nstimer准时的原因：</p>
<ul>
<li>都是源，一个是RunLoop源 一个是GCD源</li>
<li>GCDTimer不需要加入mode</li>
</ul>
<p>GCDtimer受哪些影响会不准时</p>
<ul>
<li>在主线程中运行受主线程任务多少的影响，回调给主线程是需要用到RunLoop的</li>
<li>在自线程不会受到影响</li>
</ul>
<p>GCDTimer总结</p>
<ul>
<li>GCDTimer精度高</li>
<li>GCDTimer主线程执行会受RunLoop影响，在自线程没关系</li>
<li>GCDTimer不受模式切换的影响</li>
</ul>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。</p>
<h3 id="RunLoop和PerformSelecter"><a href="#RunLoop和PerformSelecter" class="headerlink" title="RunLoop和PerformSelecter"></a>RunLoop和PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="RunLoop和GCD"><a href="#RunLoop和GCD" class="headerlink" title="RunLoop和GCD"></a>RunLoop和GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="RunLoop和网络请求"><a href="#RunLoop和网络请求" class="headerlink" title="RunLoop和网络请求"></a>RunLoop和网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>
<ul>
<li>CFSocket 是最底层的接口，只负责 socket 通信。</li>
<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt="NSURLConnection网络传输的原理"></p>
<h2 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h2><h3 id="AFNetworking的RunLoop"><a href="#AFNetworking的RunLoop" class="headerlink" title="AFNetworking的RunLoop"></a>AFNetworking的RunLoop</h3><p><a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m" target="_blank" rel="noopener">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h3 id="AsyncDisplayKit中的Runloop"><a href="#AsyncDisplayKit中的Runloop" class="headerlink" title="AsyncDisplayKit中的Runloop"></a>AsyncDisplayKit中的Runloop</h3><p><a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。<br>具体的代码可以看这里：<a href="https://github.com/facebookarchive/AsyncDisplayKit/blob/master/Source/Details/Transactions/_ASAsyncTransactionGroup.h" target="_blank" rel="noopener">_ASAsyncTransactionGroup</a>。</p>

      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/06/28/iOS基础全面分析之二(RunLoop全面分析)/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
    
<article id="post-设计模式总结大纲" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="基本的UML类图的关系"><a href="#基本的UML类图的关系" class="headerlink" title="基本的UML类图的关系"></a>基本的UML类图的关系</h2><pre><code>泛化关系（generalization）
    三角空心实线，泛化关系表现为继承非抽象类
    指向父类

实现关系（realization）   
    三角空心虚线，实现关系表现为继承抽象类
    指向接口

依赖关系（dependency）    
    箭头虚线   依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系处理临时知道对方，临时使用而并持有对方，这叫做依赖关系
    箭头指向被调用者，例如每个对象可以使用每个抽象功能，那么就指向这个抽象功能对象

关联关系－单向关联（Directed Association） 
    箭头实线  例如A知道B而B不知道A，那么B就是A的关联对象，关联对象通常是以成员变量的形式实现的，持有对方
    指向被拥有者

关联关系－双向关联（Association）
    实线  与单项关联不同的是：对象间相互知道 
    无指向

聚合关系（Aggregation）   
    空心菱形实线 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义,整体没有了，但是部分还是存在的这叫做聚合

    空心菱形指向整体，实线箭头指向部分


组合关系（Composition） 
    实心菱形实线  组合关系同样表示整体由部分构成的语义，但是它们是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了
    实心菱形指向整体，实线箭头指向成员变量

泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 
</code></pre><h2 id="设计模式之-命令模式）"><a href="#设计模式之-命令模式）" class="headerlink" title="设计模式之(命令模式）"></a>设计模式之(命令模式）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1.将一个请求封装成为一个对象，从而让用户使用不同的请求将客户端参数化
2.对请求排队或者纪录请求日志，以及支持撤销操作
</code></pre><h3 id="角色划分"><a href="#角色划分" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>接收者（负责具体的功能实现，执行具体的逻辑）   Receiver
命令接口（命令抽象）                       Command
具体的命令（调用接受者逻辑方法，行为方法）     ConcreteCommand
请求者                                   Invoker
</code></pre><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-34e35527b2d43bd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt=""></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>当需要将方法调用包装成一个对象，以延时方法调用，或者让其他组件在对其内部实现细节不了解的情况下进行调用的时候可以使用命令模式
场景一：应用程序支持撤销和恢复
场景二：记录请求日志，当系统故障这些命令可以重新被执行
场景三：想用对象参数化一个动作以执行操作，并且用不同命令对象来替换回调函数
</code></pre><h3 id="命令模式的几种表现形式"><a href="#命令模式的几种表现形式" class="headerlink" title="命令模式的几种表现形式"></a>命令模式的几种表现形式</h3><pre><code>1.基本实现
    1)我有多少个命令，我就需要添加多少个命令文件
2.DynamicCommand 动态添加命令
    1)只需要一个DynamicCommad的命令文件
    2)Manager管理对象的核心思想是performSelector:withObject:方法
    3)将我们所需要调用接受者的方法、参数以参数的形式给DynamicCommad
3.复合命令
    1)也是单一的命令文件，与其他命令类对象只执行一次命令的结果不同的是，复合命令是执行的一连串的命令(数组)
    2)在执行的过程中，遍历所有数据，依次执行。
4.GenericCommand 泛型命令    
    1)将命令对象参数以泛型的形式进行创建。
5.闭包命令
    1)与上述几种不同变种来讲，这种更加简单
    2)在传统意义上的实现上，不再需要抽象命令、具体命令对象
    3)命令的参数需要在Manager中存储
</code></pre><h2 id="设计模式之-适配器模式）"><a href="#设计模式之-适配器模式）" class="headerlink" title="设计模式之(适配器模式）"></a>设计模式之(适配器模式）</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1.将一个原始接口转成客户端需要的接口
2.原始接口不兼容现在新的接口，将他们两个可以一起工作
</code></pre><h3 id="角色划分-1"><a href="#角色划分-1" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>角色一：适配器（核心） Adapter
角色二：目标接口      Target
角色三：被适配者      Adaptee
</code></pre><h3 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-ebdc82e159ede422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt=""></p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1.接口不兼容
2.可以重复使用的类，用于与一些彼此没有太大关联的一些类一起工作
3.统一输出接口，输入端类型无法确定
</code></pre><h3 id="适配器模式的几种表现形式"><a href="#适配器模式的几种表现形式" class="headerlink" title="适配器模式的几种表现形式"></a>适配器模式的几种表现形式</h3><pre><code>1.对象适配器
    1)说白了就是在你的适配器中添加你的被适配者引用
    2)适合多个被适配者
2.类适配器
    1)直接适配器继承被适配者
    2)适合那种单一被适配者
</code></pre><h2 id="设计模式之-工厂模式：简单工厂、工厂方法、抽象工厂）"><a href="#设计模式之-工厂模式：简单工厂、工厂方法、抽象工厂）" class="headerlink" title="设计模式之(工厂模式：简单工厂、工厂方法、抽象工厂）"></a>设计模式之(工厂模式：简单工厂、工厂方法、抽象工厂）</h2><pre><code>工厂模式可以细分3个部分：简单工厂、工厂方法、抽象工厂这三种，而简单工厂又不属于GOF设计模式之一，下面就来简单介绍一下3中设计模式。
</code></pre><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>简单工厂模式
    1.简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例

工厂方法模式
    1.定义一个创建对象的统一接口或基类：组件，然后由具体实现类或子类实现该接口
    2.该组件无需了解这些实现类的细节以及它们之间的关系

抽象工厂模式
    1.为该组件提供一个创建一组相关联的对象
    2.无需知道创建对象所使用的类
</code></pre><h3 id="角色划分-2"><a href="#角色划分-2" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>简单工厂
    1.具体产品      ProductA ProductB ProductB  
    2.具体工厂      Factory   

工厂方法
    1.抽象产品      ProductProtocol
    2.具体产品      ConcreteProductA  ConcreteProductB
    3.抽象工厂      FactoryProtocol
    4.具体工厂      ConcreteFactoryA  ConcreteFactoryB

抽象工厂模式
    1.抽象产品      ProductProtocolA  ProductProtocolB
    2.具体产品          AConcreteProductA AConcreteProductB BConcreteProductA BConcreteProductB
    3.抽象工厂      FactoryProtocol
    4.具体工厂      ConcreteFactoryA  ConcreteFactoryA
</code></pre><h3 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h3><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p><img src="https://upload-images.jianshu.io/upload_images/7980283-b4b38eae4f7116e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="简单工厂.png"></p>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p><img src="https://upload-images.jianshu.io/upload_images/7980283-b9a2bf4d28baec89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450" alt="工厂方法模式通用.png"></p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p><img src="https://upload-images.jianshu.io/upload_images/7980283-497ac520395a625f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="抽象工厂通用.png"></p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>简单工厂
    该组件允许调用者根据特征来获取到相应的具体产品类，就可以使用该模式

工厂方法
    当多个类共同实现同一或者继承同一基类的时候，就可以使用该模式

抽象工厂
    如果调用组件需要创建多个相互协作的对象，且不需要知道这些对象之间有什么PY交易，那么就可以使用该模式
</code></pre><h2 id="设计模式之-策略模式）"><a href="#设计模式之-策略模式）" class="headerlink" title="设计模式之(策略模式）"></a>设计模式之(策略模式）</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 定义了一系列的算法
2. 每一种算法都是单独封装的
3. 每一种算法都可以互相替换
4. 调用者可以独立变化这些算法
</code></pre><h3 id="角色划分-3"><a href="#角色划分-3" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1.策略接口
2.具体策略
3.策略的管理器
</code></pre><h3 id="UML类图-3"><a href="#UML类图-3" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-431abee646d30f35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="策略模式.png"></p>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 针对同一类型的问题多种处理方式，仅仅只是具体的行为有所差别
2. 当你不需要修改原有类的情况下修改类的行为的时候，可以使用此模式
3. 出现了同一抽象类有多个子类，而又需要使用if -- else 或者switch -- case的时候使用该模式
</code></pre><h2 id="设计模式之-构建者模式）"><a href="#设计模式之-构建者模式）" class="headerlink" title="设计模式之(构建者模式）"></a>设计模式之(构建者模式）</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 使用构建者模式可以将创建对象的逻辑和默认配置放入到构建者类中
2. 调用者只需了解少量的配置参数就可以创建这个对象
3. 调用者无需了解也不需要知道创建对象的默认配置信息
</code></pre><h3 id="角色划分-4"><a href="#角色划分-4" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 构造者 builder
2. 具体产品 ConcreteProduct
3. 参数类  parameters
</code></pre><h3 id="UML类图-4"><a href="#UML类图-4" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-3664382730997c19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="构建者模式.png"></p>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 当创建对象需要复杂的设置，而又不想让你的配置在整个应用程序中暴漏，那么请使用构建者模式
2. 一般情况下该设计模式常常跟工厂方法、抽象工厂结合使用。
</code></pre><h2 id="设计模式之-模版方法模式"><a href="#设计模式之-模版方法模式" class="headerlink" title="设计模式之(模版方法模式)"></a>设计模式之(模版方法模式)</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 定义一个操作中的算法框架
2. 将一些步骤延时到子类实现
3. 子类可以不改变算法结构，可以重新定义算法的某些特定步骤
</code></pre><h3 id="角色划分-5"><a href="#角色划分-5" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. Template         模版类
2. ConreteTemplate  具体实现类
</code></pre><h3 id="UML类图-5"><a href="#UML类图-5" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-2ae7c2ec85e03ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="模版方法模式.png"></p>
<h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 多个子类有公有方法，且逻辑基本相同
2. 重复、复杂的算法，将核心算法设计为模版方法，其周边细节可以由子类去实现
3. 代码重构
</code></pre><h2 id="设计模式之-观察者模式"><a href="#设计模式之-观察者模式" class="headerlink" title="设计模式之(观察者模式)"></a>设计模式之(观察者模式)</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>一定一个对象间的一对多的依赖关系，当一个对象的状态发生该拜年时，所有依赖于它的对象都得到通知并被自动更新。
</code></pre><h3 id="角色划分-6"><a href="#角色划分-6" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 被观察者(目标对象)
2. 具体被观察者
3. 观察者(抽象)
4. 具体观察者   多个
</code></pre><h3 id="UML类图-6"><a href="#UML类图-6" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-b18fc1cca857c62b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="观察者模式.png"></p>
<h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象需要改变时
2. 一个对象必须通知其他对象，而它并不知道其他对象具体是什么
3. 两个抽象类型相互依赖，将它们分别封装到自己的对象中，就可以对它们单独进行改变
</code></pre><h2 id="设计模式之-迭代器模式"><a href="#设计模式之-迭代器模式" class="headerlink" title="设计模式之(迭代器模式)"></a>设计模式之(迭代器模式)</h2><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 迭代器提供了一种顺序访问聚合对象(集合)中元素的方法，而无需暴露结构的底层表示和细节。
</code></pre><h3 id="角色划分-7"><a href="#角色划分-7" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 迭代器接口
2. 具体迭代器
3. 容器接口
4. 具体容器
</code></pre><h3 id="UML类图-7"><a href="#UML类图-7" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-3078a62962192456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="迭代器模式.png"></p>
<h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 需要访问聚合或组合对象中的内容，而又不希望暴露其内部的表示。
2. 需要通过多种方式遍历组合对象。
3. 需要提供一个统一的接口，用来遍历各种类型的组合对象。
</code></pre><h3 id="迭代器的变种"><a href="#迭代器的变种" class="headerlink" title="迭代器的变种"></a>迭代器的变种</h3><pre><code>1. 外部迭代器
    1）客户端需要知道外部迭代器才能使用，但它为客户端提供了更多的控制。
    2）客户端创建和维护外部迭代器
    3）客户端可以使用不同外部迭代器实现多种类型的遍历
2. 内部迭代器
    1）客户端不需要知道任何外部迭代器，而是通过集合对象的融合接口，或者一次只访问一个元素，或者向每个元素发送消息。
    2）集合对象本身创建并维护它的外部迭代器
    3）集合对象可以在不修改客户端代码的情况下，选择不同的外部迭代器。
</code></pre><h2 id="设计模式之-原型模式）"><a href="#设计模式之-原型模式）" class="headerlink" title="设计模式之(原型模式）"></a>设计模式之(原型模式）</h2><h3 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
</code></pre><h3 id="角色划分-8"><a href="#角色划分-8" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 克隆接口
2. 具体实现类 
</code></pre><h3 id="UML类图-8"><a href="#UML类图-8" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-dd678bce9704ab0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="原型模式.png"></p>
<h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 需要创建的对象应独立于其类型与创建方式
2. 要实例化的类是在运行时决定的
3. 不想要与产品层次相对应的工厂层次
4. 不同类实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便
5. 类不容易创建，比如每个组件可把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改更加容易
</code></pre><h3 id="原型模式的变种"><a href="#原型模式的变种" class="headerlink" title="原型模式的变种"></a>原型模式的变种</h3><pre><code>1. 浅拷贝
    1）适用于值数据类型的拷贝，当数据不涉及到引用类型数据时
2. 深度拷贝
    2）适用于对象数据类型的拷贝，当数据有多个层级引用对象时
</code></pre><h2 id="设计模式之-享元模式"><a href="#设计模式之-享元模式" class="headerlink" title="设计模式之(享元模式)"></a>设计模式之(享元模式)</h2><h3 id="基本概念-9"><a href="#基本概念-9" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 运用共享技术有效地支持大量细粒度的对象。
</code></pre><h3 id="角色划分-9"><a href="#角色划分-9" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 抽象享元 (可是对象可是协议)
2. 具体享元对象
3. 享元工厂(创建管理)
</code></pre><h3 id="UML类图-9"><a href="#UML类图-9" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-527f8623b72a351b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="享元模式.png"></p>
<h3 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 系统存在大量的相似对象的时候
2. 需要使用缓冲池的时候
</code></pre><h2 id="设计模式之-组合模式"><a href="#设计模式之-组合模式" class="headerlink" title="设计模式之(组合模式)"></a>设计模式之(组合模式)</h2><h3 id="基本概念-10"><a href="#基本概念-10" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 将对象组合成树形结构以表示“部分-整体”的层次结构，组合使得用户对单一对象和组合对象的使用具有一致性。
</code></pre><h3 id="角色划分-10"><a href="#角色划分-10" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 抽象根节点 (Component)
2. 具体子节点  (Composite)
3. 叶子节点 （太监节点）
</code></pre><h3 id="UML类图-10"><a href="#UML类图-10" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-9fadc918c1ed3f01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="组合模式.png"></p>
<h3 id="应用场景-10"><a href="#应用场景-10" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 表示对象的部分-整体结构时
2. 想让客户端统一处理组合结构中的所有对象
</code></pre><h2 id="设计模式之-备忘录模式"><a href="#设计模式之-备忘录模式" class="headerlink" title="设计模式之(备忘录模式)"></a>设计模式之(备忘录模式)</h2><h3 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h3><pre><code>1. 这个模式跟命令模式相似，最大不同点就是：
    1）命令模式撤销需要一个一个去撤销无法指定恢复到哪个时间点，而备忘录模式可以
</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><pre><code>1. 行为设计模式
2. 用于保存对象的当前状态，并且以后可以再次恢复到此状态
3. 需要保证被保存的对象状态不能被对象从外部访问(为了保护好被保存的这些对象状态的完整性以及内部实现不想外暴露)
</code></pre><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态
</code></pre><h3 id="角色划分-11"><a href="#角色划分-11" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>2个核心角色，其他角色
    1. originator 备忘录创建者
    2. Memo 备忘录角色
</code></pre><h3 id="UML类图-11"><a href="#UML类图-11" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-a086b6696aaedfeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="备忘录.png">    </p>
<h3 id="应用场景-11"><a href="#应用场景-11" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 需要保存对象在某一时刻的状态或部分状态
2. 如果用一个接口来让其他对象的到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内存
</code></pre><h2 id="设计模式之-状态模式"><a href="#设计模式之-状态模式" class="headerlink" title="设计模式之(状态模式)"></a>设计模式之(状态模式)</h2><h3 id="基本概念-11"><a href="#基本概念-11" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 不同的状态，调用相同的功能，最终的效果不一样
</code></pre><h3 id="角色划分-12"><a href="#角色划分-12" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 抽象状态  StateProtocol
2. 具体状态  ConcrateState
3. 状态管理器  Context
</code></pre><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-549004ffeeb6aaef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="状态模式.png">    </p>
<h3 id="应用场景-12"><a href="#应用场景-12" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为
2. 程序代码中包含大量与对象状态有关的条件语句
</code></pre><h2 id="设计模式之-责任链设计模式"><a href="#设计模式之-责任链设计模式" class="headerlink" title="设计模式之(责任链设计模式)"></a>设计模式之(责任链设计模式)</h2><h3 id="基本概念-12"><a href="#基本概念-12" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 使多个对象有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系
2. 将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止
</code></pre><h3 id="角色划分-13"><a href="#角色划分-13" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>简单责任链设计模式
    1. 抽象处理对象    Handler  
    2. 具体处理对象    ConcreteHandler
复杂责任链设计模式     
    1. 抽象处理角色    Handler  （父类）
    2. 具体的处理角色  ConcreteHandler   多个 (子类)
    3. 抽象请求角色    Request   （父类）
    4. 具体请求角色    COncreteRequest  多个 (子类)
</code></pre><h3 id="UML类图-12"><a href="#UML类图-12" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-363c57222d826823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="责任链.png"></p>
<h3 id="应用场景-13"><a href="#应用场景-13" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>多个对象同时处理同以请求，但是由哪一个对象处理那么在运行时的时候决定。
</code></pre><h2 id="设计模式之-解析器模式"><a href="#设计模式之-解析器模式" class="headerlink" title="设计模式之(解析器模式)"></a>设计模式之(解析器模式)</h2><h3 id="基本概念-13"><a href="#基本概念-13" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 给定一个语言，定义它的文法的一种表达式，并且定义一个解析器，该解析器使用该表示来解析语言中的句子
</code></pre><h3 id="角色划分-14"><a href="#角色划分-14" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 抽象表达式     ExpressionProtocol
2. 终结符表达式   TerminatorExpression
3. 非终结符表达式  NonTerminatorExpression
4. 解析器上下文   ParserContext
</code></pre><h3 id="UML类图-13"><a href="#UML类图-13" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-e7cec85bb60ce08a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="解释器.png"></p>
<h3 id="应用场景-14"><a href="#应用场景-14" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 如果某个简单的语言需要解析之行而且可以将该语言中的语句表示为一个抽象语法树时可以使用该模式
2. 在某哦谢特订的领域出现不断重复的问题，可以将该领域的问题转化为一种语法规则下的语句，然后构建解析器来解释该语句
</code></pre><h2 id="设计模式之-桥接模式"><a href="#设计模式之-桥接模式" class="headerlink" title="设计模式之(桥接模式)"></a>设计模式之(桥接模式)</h2><h3 id="基本概念-14"><a href="#基本概念-14" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 将抽象部分和实践部分分离，使他们都可以独立的进行变化
</code></pre><h3 id="角色划分-15"><a href="#角色划分-15" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 抽象角色         Abstraction            
2. 扩展抽象角色      ExtensionAbstraction
3. 实现抽象角色          Implementor
4. 具体实现角色      ConcreteImplementor
</code></pre><h3 id="UML类图-14"><a href="#UML类图-14" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-ed7907197a75856f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="桥接模式.png"></p>
<h3 id="应用场景-15"><a href="#应用场景-15" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 开发中面临类层级结构复杂，可以使用桥接模式
2. 对不同的API之间进行桥接
3. 一个类存在俩个独立的围堵，且这俩个维度都需要进行扩展
</code></pre><h2 id="设计模式之-访问者模式"><a href="#设计模式之-访问者模式" class="headerlink" title="设计模式之(访问者模式)"></a>设计模式之(访问者模式)</h2><h3 id="基本概念-15"><a href="#基本概念-15" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 封装一些作用于某种数据结构中的各个元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新操作
</code></pre><h3 id="角色划分-16"><a href="#角色划分-16" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 抽象访问者       VisitorProtocol
    1）定义了每一个元素访问的行为
    2）它的方法参数：就是可以访问的元素
2. 具体访问者       ConcreteVisitor
    1） 给出了每一个元素类访问时所产生的具体行为
3. 元素接口         ElementProtocol
4. 具体元素         ConcreteElement
5. 对象结构(业务类)         ObjectStructure
</code></pre><h3 id="UML类图-15"><a href="#UML类图-15" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-b736bde254cd979f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="访问者.png"></p>
<h3 id="应用场景-16"><a href="#应用场景-16" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 对象结构比较稳定，但经常需要在此对象结构上定义新的操作
2. 需要对一个对象结构中的对象进行很多不同并不相关的操作，而需要避免这些操作&quot;污染&quot;这些对象类，也不希望在增加新操作时修改这些类。
</code></pre><h2 id="设计模式之-外观-门面-模式"><a href="#设计模式之-外观-门面-模式" class="headerlink" title="设计模式之(外观(门面)模式)"></a>设计模式之(外观(门面)模式)</h2><h3 id="基本概念-16"><a href="#基本概念-16" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 要求一个子系统的外部和其内部的通信必须通过一个统一的对象
2. 外观模式提供了一个高层次的接口，使得子系统更易于使用
</code></pre><h3 id="角色划分-17"><a href="#角色划分-17" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 外观角色：  Facade   为多个子系统对外提供一个共同的接口
2. 子系统角色：  SubSystem  实现系统的部分功能，客户可以通过外观角色访问
3. 客户端 ：通过一个外观角色访问各个子系统的功能
</code></pre><h3 id="UML类图-16"><a href="#UML类图-16" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-1bb792407e71231c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="外观模式.png"></p>
<h3 id="应用场景-17"><a href="#应用场景-17" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 为复杂系统提供一个简单接口
2. 当我们在构建一个层次结构的子系统时，使用Facade模式定义子系统夂每一个层入口点，如果子系统之间相互依赖，可以通过此模式简化它们之间的依赖关系。
</code></pre><h2 id="设计模式之-中介者模式"><a href="#设计模式之-中介者模式" class="headerlink" title="设计模式之(中介者模式)"></a>设计模式之(中介者模式)</h2><h3 id="基本概念-17"><a href="#基本概念-17" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 包装了一系列对象相互作用的方法，使得这些对象不必互相引用，从而使它们可以降低耦合(松散耦合)。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立变化。中介者模式将多对多的相互作用转化为一对多的相互作用。中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。
</code></pre><h3 id="角色划分-18"><a href="#角色划分-18" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. Mediator (抽象中介者)
2. ConcreteMediator (具体中介者)
3. Colleague (抽象同事)
4. ConcreteColleague (具体同事)
</code></pre><h3 id="UML类图-17"><a href="#UML类图-17" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-55e8d53b81329afb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="中介者.png"></p>
<h3 id="应用场景-18"><a href="#应用场景-18" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 当对象之间的交互操作很多且每个对象的行为操作都依赖彼此时，为防止在修改一个对象的行为时，同时设计修改很多其他对象的行为，可以采用中介者模式来解决耦合为题。

核心：解决耦合问题
</code></pre><h2 id="设计模式之-代理模式"><a href="#设计模式之-代理模式" class="headerlink" title="设计模式之(代理模式)"></a>设计模式之(代理模式)</h2><h3 id="基本概念-18"><a href="#基本概念-18" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 为其他对象提供一种代理，控制这个对象的访问。
</code></pre><h3 id="角色划分-19"><a href="#角色划分-19" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 角色一：具体代理对象  ConcreteProxy
    1）持有目标对象引用
    2）实现目标接口
2. 角色二：目标接口
3. 角色三：具体目标对象
</code></pre><h3 id="UML类图-18"><a href="#UML类图-18" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-9c83eb7bf669a32e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="代理模式.png"></p>
<h3 id="应用场景-19"><a href="#应用场景-19" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 由于一些原因，对象本身无法去完成这个方法，这个时候需要使用代理模式
</code></pre><h2 id="设计模式之-装饰模式"><a href="#设计模式之-装饰模式" class="headerlink" title="设计模式之(装饰模式)"></a>设计模式之(装饰模式)</h2><h3 id="基本概念-19"><a href="#基本概念-19" class="headerlink" title="基本概念"></a>基本概念</h3><pre><code>1. 动态的给一个对象添加一些额外的职责。
</code></pre><h3 id="角色划分-20"><a href="#角色划分-20" class="headerlink" title="角色划分"></a>角色划分</h3><pre><code>1. 抽象对象  ObjectiveProtocol
2. 具体对象  Concreteobjective
3. 抽象装饰  DecoratorProtocol
4. 具体装饰  ConcreteDecorator
</code></pre><h3 id="UML类图-19"><a href="#UML类图-19" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://upload-images.jianshu.io/upload_images/7980283-6923e9bf65f658f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/550" alt="装饰模式.png"></p>
<h3 id="应用场景-20"><a href="#应用场景-20" class="headerlink" title="应用场景"></a>应用场景</h3><pre><code>1. 需要透明且动态的扩展类的功能。
</code></pre>
      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/05/24/设计模式总结大纲/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
    
<article id="post-深入浅出iOS多线程(二)——pthraed和NSThread的使用" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/09/深入浅出iOS多线程(二)——pthraed和NSThread的使用/">深入浅出iOS多线程(二)——pthraed和NSThread的使用</a>
    </h1>
  

        
        <a href="/2019/04/09/深入浅出iOS多线程(二)——pthraed和NSThread的使用/" class="archive-article-date">
  	<time datetime="2019-04-09T10:33:22.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-04-09</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h1><h2 id="pthread简介"><a href="#pthread简介" class="headerlink" title="pthread简介"></a>pthread简介</h2><p><strong>pthread</strong> 是属于 <a href="https://baike.baidu.com/item/POSIX/3792413?fr=aladdin" target="_blank" rel="noopener">POSIX</a> 多线程开发框架，POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），如果想学习这套API，在网上是可以找到相关的资料等，由于在iOS中有NSThrad，如果不考虑移植性，那么在iOS开发中基本上不回去使用，所以只是了解，pthread是多线程的一种技术实现。</p>
<h2 id="iOS中的pthread"><a href="#iOS中的pthread" class="headerlink" title="iOS中的pthread"></a>iOS中的pthread</h2><p>在iOS中需要导入头文件<strong>pthread.h</strong>才能够使用<strong>pthrad</strong>的Api</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;pthread.h&gt;</span><br></pre></td></tr></table></figure>
<h2 id="pthraed的特点"><a href="#pthraed的特点" class="headerlink" title="pthraed的特点"></a>pthraed的特点</h2><ul>
<li>一套通用的多线程API</li>
<li>跨平台可移植</li>
<li>使用难度比较大</li>
<li>基于C语言的开发</li>
</ul>
<h2 id="pthread的简单使用"><a href="#pthread的简单使用" class="headerlink" title="pthread的简单使用"></a>pthread的简单使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 参数:</span><br><span class="line"> 1.指向线程标示的指针</span><br><span class="line"> 2.线程的属性</span><br><span class="line"> 3.指向函数的指针</span><br><span class="line"> 4.传递给该函数的参数</span><br><span class="line"> </span><br><span class="line"> 返回值</span><br><span class="line"> - 如果是0,标示正确</span><br><span class="line"> - 如果非0,标示错误代码</span><br><span class="line"> </span><br><span class="line"> void *   (*)      (void *)</span><br><span class="line"> 返回值   (函数指针)  (参数)</span><br><span class="line"> void *  和OC中的  id 是等价的!</span><br><span class="line"> </span><br><span class="line"> */</span><br><span class="line">    </span><br><span class="line">pthread_t pthreadId ;</span><br><span class="line">    </span><br><span class="line">NSString *str = @&quot;敲代码&quot;;</span><br><span class="line">    </span><br><span class="line">int result = pthread_create(&amp;pthreadId, </span><br><span class="line">						          NULL, </span><br><span class="line">								&amp;doing, </span><br><span class="line">				 (__bridge void *)(str)</span><br><span class="line">				           );</span><br><span class="line">    </span><br><span class="line">if(result == 0)&#123;</span><br><span class="line">    NSLog(@&quot;开启成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    NSLog(@&quot;开启失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void * doing(void * param)&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@,%@&quot;,[NSThread currentThread],param);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h1><h2 id="iOS的多线程NSThread简介"><a href="#iOS的多线程NSThread简介" class="headerlink" title="iOS的多线程NSThread简介"></a>iOS的多线程NSThread简介</h2><p>NSThread是苹果官方提供面向对象操作线程的技术，简单方便，可以直接操作对象，需要手动控制线程的生命周期，平时iOS开发较少使用，使用最多的是获取当前线程</p>
<h2 id="NSThread特点"><a href="#NSThread特点" class="headerlink" title="NSThread特点"></a>NSThread特点</h2><ul>
<li>面向对象的多线程编程</li>
<li>简单易用，可直接操作线程对象</li>
<li>需要手动管理线程的生命周期</li>
</ul>
<h2 id="NSThread的详细使用介绍"><a href="#NSThread的详细使用介绍" class="headerlink" title="NSThread的详细使用介绍"></a>NSThread的详细使用介绍</h2><h3 id="如何开启NSThread线程"><a href="#如何开启NSThread线程" class="headerlink" title="如何开启NSThread线程"></a>如何开启NSThread线程</h3><p><strong>NSThread初始化API</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//初始化的API</span><br><span class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument </span><br><span class="line">- (instancetype)initWithBlock:(void (^)(void))block </span><br><span class="line"></span><br><span class="line">//类对象方法</span><br><span class="line">+ (void)detachNewThreadWithBlock:(void (^)(void))block </span><br><span class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</span><br></pre></td></tr></table></figure>
<p>上述实例方法以及类对象方法，一样都是创建一个新的线程，不一样的是，类对象方法不需要创建完成以后调用<code>start</code>方法，而alloc创建的线程需要手动<code>start</code>开启。</p>
<p><strong>NSThread代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//方法一：</span><br><span class="line">NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(demo1Doing:) object:@&quot;hello&quot;];</span><br><span class="line">[thread start];</span><br><span class="line">    </span><br><span class="line">//方法二：</span><br><span class="line">NSThread *thread1 = [[NSThread alloc]initWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;];</span><br><span class="line">[thread1 start];</span><br><span class="line">    </span><br><span class="line">//方法三：</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(demo1Doing:) toTarget:self withObject:@&quot;hello&quot;];</span><br><span class="line">    </span><br><span class="line">//方法四</span><br><span class="line">[NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="NSThread主线程的API和获取主线程"><a href="#NSThread主线程的API和获取主线程" class="headerlink" title="NSThread主线程的API和获取主线程"></a>NSThread主线程的API和获取主线程</h3><ul>
<li><p>判断是否是主线程，获取主线程</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSThread *)mainThread; // 获得主线程</span><br><span class="line">- (BOOL)isMainThread; // 是否为主线程</span><br><span class="line">+ (BOOL)isMainThread; // 是否为主线程</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前线程</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSThread *current = [NSThread currentThread];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>设置和获取线程的名字</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)n;</span><br><span class="line">- (NSString *)name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="其他创建线程的方式"><a href="#其他创建线程的方式" class="headerlink" title="其他创建线程的方式"></a>其他创建线程的方式</h3><ul>
<li><p>自启动线程</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	[NSThread detachNewThreadSelector:@selector(demo1Doing:) toTarget:self withObject:@&quot;hello&quot;];</span><br><span class="line">	    </span><br><span class="line">	[NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">	    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">	&#125;];</span><br><span class="line">	```	</span><br><span class="line">- 隐式创建并启动线程</span><br></pre></td></tr></table></figure>
<ul>
<li>(void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray<nsstring *=""> *)array;</nsstring></li>
<li>(void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</li>
<li>(void)performSelector:(SEL)aSelector onThread:(NSThread <em>)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString </em>&gt; *)array;</li>
<li>(void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</li>
<li><p>(void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**总结**</span><br><span class="line"></span><br><span class="line">上述两种创建线程方式的优缺点：</span><br><span class="line"></span><br><span class="line">- 优点：简单快捷</span><br><span class="line">- 缺点：无法对线程进行更详细的设置和管理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 控制线程状态</span><br><span class="line"></span><br><span class="line">- 启动线程</span><br></pre></td></tr></table></figure>
<p>// 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</p>
</li>
<li><p>(void)start; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 阻塞线程</span><br></pre></td></tr></table></figure>
<p>//进入阻塞线程状态  休眠</p>
</li>
</ul>
<ul>
<li>(void)sleepUntilDate:(NSDate *)date;</li>
<li><p>(void)sleepForTimeInterval:(NSTimeInterval)ti;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 强制停止线程</span><br></pre></td></tr></table></figure>
<p>//进入死亡状态</p>
</li>
<li><p>(void)exit;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">### 线程的优先级</span><br><span class="line"></span><br><span class="line">- 线程的优先级API</span><br></pre></td></tr></table></figure>
</li>
<li><p>(double)threadPriority;</p>
</li>
<li><p>(BOOL)setThreadPriority:(double)p;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- 优先级设置</span><br><span class="line">	- Priorit的值 0.0～1.0之间</span><br><span class="line">	- 优先级只能保证CPU调度的可能性会高，归根究底你还是无法控制多线程的顺序，如果就靠优先级，来误认为控制多线程额顺序是不严谨的。</span><br><span class="line">		- 多线程的目的：是不阻塞UI线程</span><br><span class="line">		- 建议不要修改优先级</span><br><span class="line">		- 多线程开发中不能相信一次的运行结果</span><br><span class="line">		- **优先级翻转，优先级低的任务太耗时放到最后面，然后后面排的任务比较多，优先级高的任务被堵死了**</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">## 多线程的安全隐患问题</span><br><span class="line"></span><br><span class="line">### 安全隐患？</span><br><span class="line">- 资源共享</span><br><span class="line">	- 一块资源可能会被多个线程共享，也就是说**多个线程可能会访问同一块资源**</span><br><span class="line">	- 例如：多个线程同时访问修改同一个变量、同一个文件、同一个对象</span><br><span class="line">- 数据错乱</span><br><span class="line">	- 同一个线程修改一个数据，不同线程不同的运行结束时间，有可能得到不一样结果</span><br><span class="line"></span><br><span class="line">### 安全隐患问题分析</span><br><span class="line"></span><br><span class="line">- ThreadA去访问一块内容中的integer数据，得到数据17，17+1 = 18写入内存</span><br><span class="line">- ThreadB也在同一时间访问了integer数据，得到数据17，17+1 = 18写入内存</span><br><span class="line">- **结果**非常有意思的是+1了两次应该是19才对，最终结果是18，这就是多线程的安全隐患问题，如下图所示</span><br><span class="line">	![安全隐患.png](https://upload-images.jianshu.io/upload_images/7980283-273ef6ed8ac8849c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">## 如何解决多线程的安全隐患(线程锁)</span><br><span class="line"></span><br><span class="line">### 互斥锁</span><br><span class="line"></span><br><span class="line">- 当ThreadA去访问一块内容中的integer数据的时候，首先上一把锁`lock`得到数据17，17+1 = 18写入内存,最后在`unlock`</span><br><span class="line">- ThreadB也在同一时间访问了integer数据：</span><br><span class="line">	- 由于ThreadA已经在数据上面加了锁`lock`，所以必须等到ThreadA完成以后才能去访问这个数据</span><br><span class="line">	- ThreadA完成，访问integer数据时，时候`lock`然后在获取数据18，18+1 = 19写入内存，最后在`unlock`</span><br></pre></td></tr></table></figure>
<p>  //互斥锁<br>  @synchronized (self) {<br>  }<br>  <code></code>    </p>
</li>
</ul>
<ul>
<li><code>@synchronized</code>的参数：<ul>
<li>任意OC对象都可以加锁</li>
<li>加锁一定要加锁共有的对象，一般用self</li>
</ul>
</li>
</ul>
</li>
<li><p>互斥锁的优缺点：</p>
<ul>
<li>优点：能有效防止因多线程抢夺资源造成的数据安全问题</li>
<li>缺点：需要消耗大量的CPU资源</li>
</ul>
</li>
<li>互斥锁的使用前提<ul>
<li>多条线程抢夺同一块资源</li>
</ul>
</li>
<li>线程同步<ul>
<li>线程同步的意思就是：多条线程同一条线上工作(按顺序地执行任务)</li>
<li>互斥锁，就使用了线程同步技术        </li>
</ul>
</li>
</ul>
<h3 id="互斥锁需要注意的地方"><a href="#互斥锁需要注意的地方" class="headerlink" title="互斥锁需要注意的地方"></a>互斥锁需要注意的地方</h3><ul>
<li>保证代码内的代码，同一时间，只有一条线程执行</li>
<li><p>互斥锁的范围应该尽量小，范围大了，效率就差</p>
</li>
<li><p><strong>结果</strong>本身是一个多线程开发，最后结果变成了同步去执行，互斥锁，也就是同步线程技术，如下图所示：<br>  <img src="https://upload-images.jianshu.io/upload_images/7980283-b02c1db797008e82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="互斥锁.png"></p>
</li>
</ul>
<h2 id="如何解决多线程的安全隐患-原子与非原子对象"><a href="#如何解决多线程的安全隐患-原子与非原子对象" class="headerlink" title="如何解决多线程的安全隐患(原子与非原子对象)"></a>如何解决多线程的安全隐患(原子与非原子对象)</h2><h3 id="nonatomic-非原子属性"><a href="#nonatomic-非原子属性" class="headerlink" title="nonatomic 非原子属性"></a>nonatomic 非原子属性</h3><ul>
<li>不会为setter方法加锁</li>
<li>非原子属性，因为<code>atomic</code>所有对这个对象的操作之前会加锁，所以会很耗费资源，在没有安全隐患的问题上在加锁，是不必要的</li>
</ul>
<h3 id="atomic-原子属性"><a href="#atomic-原子属性" class="headerlink" title="atomic 原子属性"></a>atomic 原子属性</h3><ul>
<li>为setter方法加锁(默认是atomic)</li>
<li><p>原子属性，保证这个属性的安全性(线程安全)，多线程写入这个对象的时候，保证同一时间只有一个线程能够执行！</p>
<ul>
<li><p>模拟一个<code>atomic</code>原子属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//模拟原子属性</span><br><span class="line">- (void)setMyAtomic:(NSObject *)myAtomic&#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        _myAtomic = myAtomic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际上，原子属性内部有一个锁，自旋锁：</p>
</li>
<li>自旋锁和互斥锁不一样的地方<ul>
<li>共同点：都能够保证线程的安全</li>
<li>不同点：互斥锁：如果线程被锁到外面，线程就会进入休眠状态，等待锁打开，打开之后被唤醒；自旋锁：如果线程被锁在外面，就会用死循环的方式，一直等待锁打开。</li>
</ul>
</li>
<li>无论什么锁，都会消耗新能，效率不高</li>
<li>线程安全<ul>
<li>在多个线程进行读写操作时，仍然保证数据正确</li>
</ul>
</li>
</ul>
</li>
<li><p>UI线程</p>
<ul>
<li>共同的约定，所有更新UI的操作都放在主线程执行</li>
<li>因为UIKit 框架都是线程不安全的(因为线程安全效率低下)</li>
</ul>
</li>
<li><p><strong>nonatomic和atomic对比</strong></p>
<ul>
<li>atomic：线程安全，需要消耗大量的资源</li>
<li>nonatomic：非线程安全，适合内存小的移动设备</li>
</ul>
</li>
<li><p>iOS开发使用nonatomic和atomic</p>
<ul>
<li>所有属性都应声明nonatomic</li>
<li>尽量避免多线程抢夺同一块资源</li>
<li>尽量将加锁、资源抢夺的业务逻辑交给服务器处理，减小移动客户端的压力</li>
</ul>
</li>
</ul>
<p><strong>注意一个小细节</strong></p>
<ul>
<li>OC中：定义一个属性，通常会生成<em>成员变量，如果同时重写了getter、setter那么</em>成员变量就不会自动生成<ul>
<li>如果想要同时重写了getter、setter，那么就直接使用 @synthesize myAtomic = _myAtomic;</li>
</ul>
</li>
</ul>
<h2 id="NSThread自定义"><a href="#NSThread自定义" class="headerlink" title="NSThread自定义"></a>NSThread自定义</h2><p>在NSThread的有<code>init</code>初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//用alloc init 适用于自定义NSThread (子类)</span><br><span class="line">NSThread * t = [[NSThread alloc]init];</span><br><span class="line">需要创建一个新的子类继承NSThread方法，然后重写main方法</span><br></pre></td></tr></table></figure>
<h2 id="多线程下载网络图片"><a href="#多线程下载网络图片" class="headerlink" title="多线程下载网络图片"></a>多线程下载网络图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(void)loadView&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果重新了上述方法，SB和XIB都无效</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()&lt;UIScrollViewDelegate&gt;</span><br><span class="line">@property(nonatomic,strong)UIScrollView * scrollView;</span><br><span class="line">@property(nonatomic,weak) UIImageView * imageView;</span><br><span class="line">@property(nonatomic,strong) UIImage * image;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 加载视图结构的,纯代码开发</span><br><span class="line"> 功能 SB&amp;XIB 是一样</span><br><span class="line"> 如果重写了这个方法,SB和XIB 都无效</span><br><span class="line"> */</span><br><span class="line">-(void)loadView&#123;</span><br><span class="line">    //搭建界面</span><br><span class="line">    self.scrollView = [[UIScrollView alloc]initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">    self.view = self.scrollView;</span><br><span class="line">    //MARK:- 设置缩放属性</span><br><span class="line">    self.scrollView.delegate = self;</span><br><span class="line">    self.scrollView.minimumZoomScale = 0.1;</span><br><span class="line">    self.scrollView.maximumZoomScale = 2.0;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //imageView</span><br><span class="line">    UIImageView * iv = [[UIImageView alloc]init];</span><br><span class="line">    //会调用View的getter方法. loadView方法在执行的过程中!如果self.view == nil,会自动调用loadView加载!</span><br><span class="line">    [self.view addSubview:iv];</span><br><span class="line">    self.imageView = iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line"></span><br><span class="line">    NSThread * t1 = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage) object:nil];</span><br><span class="line">    [t1 start];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//MARK: - 下载图片</span><br><span class="line">-(void)downloadImage&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    //NSURL -&gt; 统一资源定位符,每一个URL 对应一个网络资源!</span><br><span class="line">    NSURL * url = [NSURL URLWithString:@&quot;https://images.unsplash.com/photo-1496840220025-4cbde0b9df65?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2734&amp;q=80&quot;];</span><br><span class="line">    </span><br><span class="line">    //下载图片(在网络上传输的所有数据都是二进制!!)</span><br><span class="line">    //为什么是二进制:因为物理层!!是网线!!网线里面是电流!!电流有高低电频!!高低电频表示二进制!!!</span><br><span class="line">    NSData * data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">    </span><br><span class="line">    //将二进制数据转成图片并且设置图片</span><br><span class="line">    //提示:不是所有的更新UI在后台线程支持都会有问题!!!</span><br><span class="line">    //重点提示:不要去尝试在后台线程更新UI!!!出了问题是非常诡异的!!</span><br><span class="line">    //    self.image = [UIImage imageWithData:data];</span><br><span class="line">    </span><br><span class="line">    //在UI线程去更新UI</span><br><span class="line">    /**</span><br><span class="line">     * 1.SEL:在主线程执行的方法</span><br><span class="line">     * 2.传递给方法的参数</span><br><span class="line">     * 3.让当前线程等待 (注意点!! 如果当前线程是主线程!哥么YES没有用!!)</span><br><span class="line">     */</span><br><span class="line">    // 线程间通讯</span><br><span class="line">    [self performSelectorOnMainThread:@selector(setImage:) withObject:[UIImage imageWithData:data] waitUntilDone:NO];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这种写法 省略一个 _image ,主要原因是因为image 保存在了imageView里面了!</span><br><span class="line">-(UIImage *)image&#123;</span><br><span class="line">    return self.imageView.image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(void)setImage:(UIImage *)image&#123;</span><br><span class="line">    NSLog(@&quot;更新 UI 在====%@&quot;,[NSThread currentThread]);</span><br><span class="line">    //直接将图片设置到控件上</span><br><span class="line">    self.imageView.image = image;</span><br><span class="line">    //让imageView和image一样大</span><br><span class="line">    [self.imageView sizeToFit];</span><br><span class="line">    //指定ScrollView 的contentSize</span><br><span class="line">    self.scrollView.contentSize = image.size;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;\n\n\n\n\n\n\n\n\n\n\n%@&quot;,self.image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - &lt;scrollView代理&gt;</span><br><span class="line">//告诉 ScrollView 缩放哪个View</span><br><span class="line">-(UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView&#123;</span><br><span class="line">    return self.imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * transform 矩阵</span><br><span class="line"> *  CGFloat a(缩放比例), b, c, d(缩放比例);  共同决定角度!</span><br><span class="line"> *  CGFloat tx(x方向位移), ty(y方向的位移);</span><br><span class="line"> </span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">-(void)scrollViewDidZoom:(UIScrollView *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromCGAffineTransform(self.imageView.transform));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>提示:不是所有的更新UI在后台线程支持都会有问题!!!</li>
<li>重点提示:不要去尝试在后台线程更新UI!!!出了问题是非常诡异的!!</li>
<li><p>在UI线程去更新UI</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 1.SEL:在主线程执行的方法</span><br><span class="line">   * 2.传递给方法的参数</span><br><span class="line">   * 3.是否让当前线程等待 (注意点!! 如果当前线程是主线程!YES没有用!!)</span><br><span class="line">   * NO当前线程不需要等待@selector(setImage:)执行完成，YES当前线程需要等待@selector(setImage:)执行完成</span><br><span class="line">   */</span><br><span class="line">   // 线程间通讯</span><br><span class="line">  [self performSelectorOnMainThread:@selector(setImage:) withObject:[UIImage imageWithData:data] waitUntilDone:NO];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (NSThreadPerformAdditions)</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="NSPort实现线程通信"><a href="#NSPort实现线程通信" class="headerlink" title="NSPort实现线程通信"></a>NSPort实现线程通信</h3><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController () &lt;NSPortDelegate&gt;</span><br><span class="line">@property (nonatomic, strong) NSPort* subThreadPort;</span><br><span class="line">@property (nonatomic, strong) NSPort* mainThreadPort;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.mainThreadPort = [NSPort port];</span><br><span class="line">    self.mainThreadPort.delegate = self;</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:self.mainThreadPort forMode:NSDefaultRunLoopMode];</span><br><span class="line">    [self task];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) task &#123;</span><br><span class="line">    NSThread* thread = [[NSThread alloc] initWithBlock:^&#123;</span><br><span class="line">        self.subThreadPort = [NSPort port];</span><br><span class="line">        self.subThreadPort.delegate = self;</span><br><span class="line">        </span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:self.subThreadPort forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    &#125;];</span><br><span class="line">    [thread setName:@&quot;子线程&quot;];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handlePortMessage:(id)message &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    if (![[NSThread currentThread] isMainThread]) &#123;</span><br><span class="line">        NSMutableArray* sendComponents = [NSMutableArray array];</span><br><span class="line">        NSData* data = [@&quot;world&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">        [sendComponents addObject:data];</span><br><span class="line">        [self.mainThreadPort sendBeforeDate:[NSDate date] components:sendComponents from:self.subThreadPort reserved:0];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSMutableArray* components = [message valueForKey:@&quot;components&quot;];</span><br><span class="line">    </span><br><span class="line">    if ([components count] &gt; 0) &#123;</span><br><span class="line">        NSData* data = [components objectAtIndex:0];</span><br><span class="line">        NSString* str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">        NSLog(@&quot;%@&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray* components = [NSMutableArray array];</span><br><span class="line">    NSData* data = [@&quot;hello&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    [components addObject:data];</span><br><span class="line">    </span><br><span class="line">    [self.subThreadPort sendBeforeDate:[NSDate date] components:components from:self.mainThreadPort reserved:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="NSThread需要注意的地方"><a href="#NSThread需要注意的地方" class="headerlink" title="NSThread需要注意的地方"></a>NSThread需要注意的地方</h2><h3 id="子线程执行太快，还会调用线程通信的代码吗？"><a href="#子线程执行太快，还会调用线程通信的代码吗？" class="headerlink" title="子线程执行太快，还会调用线程通信的代码吗？"></a>子线程执行太快，还会调用线程通信的代码吗？</h3><p>不会<br>有时候会出现这个问题，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    NSThread * t1 = [[NSThread alloc]initWithTarget:self selector:@selector(demo) object:nil];</span><br><span class="line">    [t1 start];</span><br><span class="line">    //不执行地方原因,是因为 demo 方法执行的快!&quot;&quot;</span><br><span class="line">    [self performSelector:@selector(otherMethod) onThread:t1 withObject:nil waitUntilDone:NO];</span><br><span class="line">    </span><br><span class="line">-(void)demo&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">-(void)otherMethod&#123;</span><br><span class="line"></span><br><span class="line">    self.finished = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Demo执行额太快，因为子线程是没有RunLoop的，当demo执行完成以后就消失了，所以不会在执行<code>otherMethod</code>。</li>
</ul>
<h3 id="如何解决上述问题"><a href="#如何解决上述问题" class="headerlink" title="如何解决上述问题"></a>如何解决上述问题</h3><p>在子线程开启RunLoop，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    NSThread * t1 = [[NSThread alloc]initWithTarget:self selector:@selector(demo) object:nil];</span><br><span class="line">    [t1 start];</span><br><span class="line">    //不执行地方原因,是因为 demo 方法执行的快!&quot;&quot;</span><br><span class="line">    [self performSelector:@selector(otherMethod) onThread:t1 withObject:nil waitUntilDone:NO];</span><br><span class="line">    </span><br><span class="line">-(void)demo&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">   [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;</span><br><span class="line">-(void)otherMethod&#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;,__FUNCTION__,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>RunLoop开启了循环，这样就会无限制的进行循环，这样这个子线程就永远不会释放</p>
</li>
<li><p>改进的办法就是，从外面创建一个<code>BOOL</code>来判断是否需要关闭<code>RunLoop</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">/** 循环条件 */</span><br><span class="line">@property(assign,nonatomic,getter=isFinished)BOOL finished;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NSThread * t1 = [[NSThread alloc]initWithTarget:self selector:@selector(demo) object:nil];</span><br><span class="line">    [t1 start];</span><br><span class="line">    </span><br><span class="line">    self.finished = NO;</span><br><span class="line">    </span><br><span class="line">    //不执行地方原因,是因为 demo 方法执行的快!&quot;&quot;</span><br><span class="line">    [self performSelector:@selector(otherMethod) onThread:t1 withObject:nil waitUntilDone:NO];</span><br><span class="line"></span><br><span class="line">-(void)demo&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    //启动当前RunLoop  哥么就是一个死循环!!</span><br><span class="line">    //使用这种方式,可以自己创建一个线程池!</span><br><span class="line">    //    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    </span><br><span class="line">    //在OC中使用比较多的,退出循环的方式!</span><br><span class="line">    while (!self.isFinished) &#123;</span><br><span class="line">        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-(void)otherMethod&#123;</span><br><span class="line">    for (int i = 0; i&lt;10; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%s %@&quot;,__FUNCTION__,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    self.finished = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/04/09/深入浅出iOS多线程(二)——pthraed和NSThread的使用/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
    
<article id="post-深入浅出iOS多线程(一)——线程的概念" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">

    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/08/深入浅出iOS多线程(一)——线程的概念/">深入浅出iOS多线程(一)——线程的概念</a>
    </h1>
  

        
        <a href="/2019/04/08/深入浅出iOS多线程(一)——线程的概念/" class="archive-article-date">
  	<time datetime="2019-04-08T13:09:56.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-04-08</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>想要深入线程就必须了解进程。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h2><p><strong>进程是正在运行的程序的实例</strong>,是<strong>一个具有独立功能的程序关于某个数据集合的一次运行活动</strong>。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。是<strong>系统进行资源分配和调度的基本单位，是操作系统结构的基础</strong>。</p>
<h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><ul>
<li>进程是一个实体(文本区域、数据区域、堆栈区域)</li>
<li>进程是一个“执行中的程序”(操作系统正在执行的程序)</li>
</ul>
<h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><ul>
<li>动态行：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。</li>
<li>并发性：任何进程都可以同其他进程一起并发执行。</li>
<li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。</li>
<li>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。</li>
</ul>
<h2 id="进程的应用"><a href="#进程的应用" class="headerlink" title="进程的应用"></a>进程的应用</h2><p>Mac中执行的Xcode、在活动监视器中查看到的进程，都是进程的应用。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><p>线程是指程序在执行过程中，能够执行程序代码的一个执行单元，是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<h2 id="主要概念-1"><a href="#主要概念-1" class="headerlink" title="主要概念"></a>主要概念</h2><ul>
<li>进程中可以拥有多个线程，但是至少有一个线程</li>
<li>进程的任务都在线程中执行。</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>轻型实体</strong>线程的实体基本上不拥有系统资源，只是有一点必不可少、能够保证独立运行的资源。</li>
<li><strong>独立调度和分派的基本单位</strong>线程是能独立运行的基本单位，因而也是调度跟分派的基本单位，由于线程很轻所以线程切换非常快并且开销小。</li>
<li><strong>可并发执行</strong>在一个进程中的多个线程之间，可以并发执行。</li>
<li><strong>共享进程资源</strong>在同一个线程中的各个线程，都可以共享该进程的所有资源。</li>
</ul>
<h2 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a>线程与进程的区别？</h2><ul>
<li>资源：同一进程里的所有线程是资源共享的，进程与进程之间是相互独立的，某一个进程之中的线程在其他进程中不可见。</li>
<li>通信：进程的通讯需要IPC，而线程之间的通信可以通过全局变量来进行通信，不过这种通信需要同步锁、互斥锁的帮助来保证数据的一致性。</li>
<li>调度和切换：线程切换比进程切换快很多。</li>
<li>线程不是一个可执行的实体。</li>
</ul>
<h2 id="线程的串行"><a href="#线程的串行" class="headerlink" title="线程的串行"></a>线程的串行</h2><h3 id="线程中的任务的执行是串行的。"><a href="#线程中的任务的执行是串行的。" class="headerlink" title="线程中的任务的执行是串行的。"></a>线程中的任务的执行是串行的。</h3><ul>
<li>如果要在一个线程中执行多个任务，那么只能一个一个的去执行</li>
<li>同一时间内，一个线程只能执行一个任务</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们在一个线程中下载3个图片，img1、img2、img3</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-4cef3dfe28d4ea09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="多个线程的并行"><a href="#多个线程的并行" class="headerlink" title="多个线程的并行"></a>多个线程的并行</h2><h3 id="多个线程之间默认是并行的"><a href="#多个线程之间默认是并行的" class="headerlink" title="多个线程之间默认是并行的"></a>多个线程之间默认是并行的</h3><ul>
<li>一个进程可以开启多个线程，每个线程可以并行的去执行任务。</li>
<li>多线程技术可以提高程序的执行效率。</li>
</ul>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>在一个线程中下载多个文件，是串行的，那么下载3个img开启3个线程？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-039f82074420effa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开启多个任务的并行线程.png"></p>
<h2 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h2><ul>
<li>同一时间，CPU只能处理一个线程，只有一个线程在工作。</li>
<li>多线程的并发执行，其实是cpu快速的在多条线程之间调度(切换)</li>
<li>如果CPU调度线程的时间足够快，就造成了多个线程并发执行的假象。</li>
</ul>
<h3 id="多线程的状态"><a href="#多线程的状态" class="headerlink" title="多线程的状态"></a>多线程的状态</h3><p>多个线程并发的实现原理：</p>
<p>1.<strong>就绪：</strong>当创建一个线程的时候，New了一个thread，从Start开始，这个线程会进入到就绪状态，也就是当前线程已在可调度线程池中。</p>
<p>2.<strong>执行：</strong>CPU会自动运行和切换可调度线程池中的线程。</p>
<p>3.<strong>阻塞：</strong>如果sleep、锁等操作可以将线程阻塞，并移除可调度线程池中的当前线程，sleep、锁等完成以后，将当前线程加入到可调度线程池中。</p>
<p>4.<strong>死亡：</strong>当线程池执行完毕，或者异常强制退出的时候，该线程被移除可调度线程池，并死亡(Dead)。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7980283-ca552301a0abf613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>提高执行效率</li>
<li>提高资源利用率</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>创建线程是有开销的。</li>
<li>开启大量线程，会降低程序的性能。</li>
<li>线程越多，CPU的调度开销就越大。</li>
<li>程序会变得复杂，线程的通信，线程的数据共享等。</li>
</ul>
<h2 id="多线程在iOS开发中的应用"><a href="#多线程在iOS开发中的应用" class="headerlink" title="多线程在iOS开发中的应用"></a>多线程在iOS开发中的应用</h2><h3 id="iOS主线程"><a href="#iOS主线程" class="headerlink" title="iOS主线程"></a>iOS主线程</h3><ul>
<li>一个iOS程序运行后，默认会开启一个线程：<strong>主线程</strong></li>
</ul>
<h3 id="iOS主线程的作用"><a href="#iOS主线程的作用" class="headerlink" title="iOS主线程的作用"></a>iOS主线程的作用</h3><ul>
<li>显示、刷新UI界面</li>
<li>处理UI事件</li>
</ul>
<h3 id="使用须知"><a href="#使用须知" class="headerlink" title="使用须知"></a>使用须知</h3><ul>
<li>耗时操作不要放入主线程，如果放入主线程会影响UI的流畅度，造成卡顿</li>
</ul>
<h2 id="iOS中多线程的实现方式"><a href="#iOS中多线程的实现方式" class="headerlink" title="iOS中多线程的实现方式"></a>iOS中多线程的实现方式</h2><table>
<thead>
<tr>
<th>方案</th>
<th>简介</th>
<th>语言</th>
<th>生命周期管理</th>
<th>使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread</td>
<td>1.一套通用的多线程API。2.适用于Unix、Linux、Windows操作系统。3.跨平台、可移植。4.使用难度大</td>
<td>C</td>
<td>手动管理</td>
<td>几乎不用</td>
</tr>
<tr>
<td>NSThread</td>
<td>1.使用更加面向对戏那个。2.简单易用，可直接操作线程对象</td>
<td>OC</td>
<td>手动管理</td>
<td>较少使用</td>
</tr>
<tr>
<td>GCD</td>
<td>1.替代NSThread等线程技术。2.充分利用设备的多核。</td>
<td>C</td>
<td>自动管理</td>
<td>经常使用</td>
</tr>
<tr>
<td>NSOperation</td>
<td>1.基于GCD（底层GCD）。2.比GCD多了一些更简单实用的功能。3.使用更加面向对象</td>
<td>OC</td>
<td>自动管理</td>
<td>经常使用</td>
</tr>
</tbody>
</table>

      




      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2019/04/08/深入浅出iOS多线程(一)——线程的概念/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">小知识</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Runtime</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Objective-C</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">消息转发</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">字典转模型</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Runtime的应用</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Cocos Creator</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">游戏</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Cocos Creator游戏UI</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">生活杂记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">经验笔记</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">&lt;br&gt;GanggangGao&lt;br&gt; &lt;br&gt;开头三个g,努力奋斗! 所以&lt;br&gt; &lt;br&gt;Struggle3g&lt;br&gt; &lt;br&gt;Coding&lt;br&gt;</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>